{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/alpha-dust-dk/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/alpha-dust-dk/source/img/bg-pattern.png","path":"img/bg-pattern.png","modified":0,"renderable":1},{"_id":"themes/alpha-dust-dk/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1}],"Cache":[{"_id":"source/about.md","hash":"034109c70c90c24857da16e71b3b2a0afbfa0154","modified":1509176010457},{"_id":"source/contact.md","hash":"312f4bc171a6b9d299cf5717a88dea1431c4816a","modified":1509176010457},{"_id":"themes/alpha-dust-dk/.gitignore","hash":"2aa039aab52800662710bbf503671c770af96621","modified":1509176208230},{"_id":"themes/alpha-dust-dk/LICENSE","hash":"20fb6ab02264ce4860e25cd70b50fa86c08f1cf8","modified":1509176208230},{"_id":"themes/alpha-dust-dk/README.md","hash":"82326b64f6b6c12dc8d3119096a003b0f51be547","modified":1509176208230},{"_id":"themes/alpha-dust-dk/_config.yml","hash":"5a7d24de8c45610d5c9bef2a1d5b2aa0d36bfab0","modified":1509189183752},{"_id":"source/_posts/csharp-metaprogramming.md","hash":"9866ed1cdc4b953750b0097887964fccacf4b5ef","modified":1512480629407},{"_id":"source/_posts/mono-on-Linux manual.md","hash":"7b334a6990b22d635fc9a5556fe7635ee60518fa","modified":1512399441799},{"_id":"source/_posts/opentk-manual.md","hash":"fbe8d914927cb172f158f52e7b74267ef01a1b68","modified":1509176010457},{"_id":"source/categories/index.md","hash":"0b11c999a2de80fbee9aa01046f99fded6c5911b","modified":1509176010457},{"_id":"source/_posts/small things.md","hash":"2cd57218b5494a27882d9403895a7157ef417747","modified":1512399105341},{"_id":"source/tags/index.md","hash":"e61ab2c947a391745890c6e1340ef7c940074fbe","modified":1509176010457},{"_id":"themes/alpha-dust-dk/.git/FETCH_HEAD","hash":"64ce2576507d428dc4cc488c95c7b9070612befc","modified":1509185820546},{"_id":"themes/alpha-dust-dk/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1509176187454},{"_id":"themes/alpha-dust-dk/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1509176208214},{"_id":"themes/alpha-dust-dk/.git/index","hash":"35aa9380d08e931e076dc983dab9e54f2e3f1542","modified":1509185794637},{"_id":"themes/alpha-dust-dk/.git/config","hash":"5790502d5a52e56ac24fbd71105ea4a94c90c4e3","modified":1509176208214},{"_id":"themes/alpha-dust-dk/.git/packed-refs","hash":"51e4ac46f3a81135d16399f540cf2673f7cf8cb2","modified":1509176208214},{"_id":"themes/alpha-dust-dk/languages/en.yml","hash":"9debce519356b44354cf1a613f8916321e572d7f","modified":1509176208230},{"_id":"themes/alpha-dust-dk/languages/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1509176208230},{"_id":"themes/alpha-dust-dk/languages/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1509176208230},{"_id":"themes/alpha-dust-dk/languages/default.yml","hash":"bc4b0f68c3579f8d9c217b96ae9d2da1991c92f7","modified":1509176208230},{"_id":"themes/alpha-dust-dk/languages/fr.yml","hash":"e9e6f7cb362ebb7997f11027498a2748fe3bac95","modified":1509176208230},{"_id":"themes/alpha-dust-dk/languages/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1509176208230},{"_id":"themes/alpha-dust-dk/languages/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1509176208230},{"_id":"themes/alpha-dust-dk/languages/pt.yml","hash":"1d0c3689eb32fe13f37f8f6f303af7624ebfbaf0","modified":1509176208230},{"_id":"themes/alpha-dust-dk/languages/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1509176208230},{"_id":"themes/alpha-dust-dk/languages/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1509176208230},{"_id":"themes/alpha-dust-dk/languages/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/archive.ejs","hash":"535ea1205c3dd8782aa8dec64c5bb67a5e118be9","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/index.ejs","hash":"a3f94e4a627a83735b82d93694980e988a32d65e","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/layout.ejs","hash":"2655449a77b370284e6af41aa72c7d72660008fa","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/page.ejs","hash":"861c947cbde087b515bfeb6121c16ed5bbb847d9","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/post.ejs","hash":"5c6c8d3c249c64c4879276d12159a50d5b65b775","modified":1509176208230},{"_id":"themes/alpha-dust-dk/template/archive.html","hash":"239ef36831f10f892ecdbf4438994d62cc973caa","modified":1509176208230},{"_id":"themes/alpha-dust-dk/template/index.html","hash":"8f5f763e912a2f84306e3857b476c5cd1c048cb0","modified":1509176208238},{"_id":"themes/alpha-dust-dk/template/post.html","hash":"8c586749ca621e6b24c07d792cb28c7827a0ed21","modified":1509176208238},{"_id":"themes/alpha-dust-dk/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1509176187454},{"_id":"themes/alpha-dust-dk/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1509176187454},{"_id":"themes/alpha-dust-dk/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1509176187454},{"_id":"themes/alpha-dust-dk/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1509176187454},{"_id":"themes/alpha-dust-dk/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1509176187454},{"_id":"themes/alpha-dust-dk/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1509176187454},{"_id":"themes/alpha-dust-dk/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1509176187454},{"_id":"themes/alpha-dust-dk/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1509176187454},{"_id":"themes/alpha-dust-dk/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1509176187454},{"_id":"themes/alpha-dust-dk/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1509176187454},{"_id":"themes/alpha-dust-dk/.git/logs/HEAD","hash":"59a0b96aa6bb45fb340c2eaa01a916d5240b5db6","modified":1509176208214},{"_id":"themes/alpha-dust-dk/layout/_partial/after-footer.ejs","hash":"15d1d1376aabe398cce7d18ff4af41635970dd29","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/_partial/article-archive.ejs","hash":"460768ed91c4bf71199f01685d7af385354ffd28","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/_partial/article-long.ejs","hash":"f2b2d0165cb35e30c9764c324e530f487e7de59e","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/_partial/article-short.ejs","hash":"792602a61177c8059ef27efd695532f456c8ca84","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/_partial/comments.ejs","hash":"423529d88d45e0a928f6cfadcf9aef27ccb63c13","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/_partial/footer.ejs","hash":"1723a9bebcafc39007f58f2fbce597a2836f8276","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/_partial/footer_categories.ejs","hash":"1831ae75b1deb1729e858b2cd83e32fff3a33f6f","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/_partial/footer_recent_posts.ejs","hash":"569addbbc7d548fca4986e09631489f8515280ff","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/_partial/gallery.ejs","hash":"80c3758b90fe6c197b52602456e2c4dcf7167847","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/_partial/head.ejs","hash":"668eca04a5e2ff2dbd2d99135b2a5428686e73d8","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/_partial/google-analytics.ejs","hash":"4e6e8de9becea5a1636a4dcadcf7a10c06e2426e","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/_partial/header.ejs","hash":"c189a234d36c6b5c51f814007d5d779bf42f0191","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/_partial/tag-cat-item.ejs","hash":"62e78d4f9cccaa1f32121309498596d6b4c5f0ad","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/_partial/menu.ejs","hash":"452e31aa3016cdf9febfe5c2597a335417873f08","modified":1509176208230},{"_id":"themes/alpha-dust-dk/layout/_partial/pagination.ejs","hash":"b9ec572a16d79cba2341211d7623cd04d2b6e521","modified":1509176208230},{"_id":"themes/alpha-dust-dk/source/js/main.js","hash":"7ee829ab42cf4d81280d20b5d664759436b19075","modified":1509176208230},{"_id":"themes/alpha-dust-dk/source/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1509176208230},{"_id":"themes/alpha-dust-dk/source/css/style.styl","hash":"47e8e5969922a74d0df6f3e8686b538a22db04ae","modified":1509176208230},{"_id":"themes/alpha-dust-dk/template/css/style.css","hash":"5b0d10f0b3a467cf9d152bd8010f6fb809a926c8","modified":1509189487357},{"_id":"themes/alpha-dust-dk/template/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1509187982826},{"_id":"themes/alpha-dust-dk/template/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1509176208230},{"_id":"themes/alpha-dust-dk/template/css/style.styl","hash":"792ff84e3a2b75cbdc216c8b37089eff0c4ec6bc","modified":1509176208230},{"_id":"themes/alpha-dust-dk/template/img/bg-pattern copy.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1509176208238},{"_id":"themes/alpha-dust-dk/template/img/bg-pattern-blue.png","hash":"07016986a35c5bfc04c1599829d6a4798c966731","modified":1509176208238},{"_id":"themes/alpha-dust-dk/template/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1509176208238},{"_id":"themes/alpha-dust-dk/template/img/hex-bg.png","hash":"a8444a553dd0fd7db09eda830bd3346cc87fc60e","modified":1509176208238},{"_id":"themes/alpha-dust-dk/template/js/main.js","hash":"656d203e231f4533d97654816ff285fcbdfd0956","modified":1509176208238},{"_id":"themes/alpha-dust-dk/template/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1509176208234},{"_id":"themes/alpha-dust-dk/template/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1509176208234},{"_id":"themes/alpha-dust-dk/template/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1509176208238},{"_id":"themes/alpha-dust-dk/template/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1509176208238},{"_id":"themes/alpha-dust-dk/template/img/session_image.jpeg","hash":"5a3669c0564044f56cb7cea464119a8e388fb18f","modified":1509176208238},{"_id":"themes/alpha-dust-dk/.git/refs/heads/master","hash":"6c035dbe6bbf4d58c34ad8fb6da8c8ad27e082e4","modified":1509176208214},{"_id":"themes/alpha-dust-dk/.git/objects/pack/pack-cc02715080c97efacf3052cc5738c1b12ba175bf.idx","hash":"22cb94cc6eea58c979cacfef714df54b3dd295ca","modified":1509176208206},{"_id":"themes/alpha-dust-dk/source/css/_partial/archive.styl","hash":"77f7b4341cb8d12191035150de6bb04635eb2a89","modified":1509176208230},{"_id":"themes/alpha-dust-dk/source/css/_partial/base.styl","hash":"f01047771a92520cf318930331517f4c9e70c04a","modified":1509176208230},{"_id":"themes/alpha-dust-dk/source/css/_partial/footer.styl","hash":"0a086dfb77bc55b27378f97e442e3a696f69048f","modified":1509176208230},{"_id":"themes/alpha-dust-dk/source/css/_partial/code.styl","hash":"3d2bbfef131c2f3fc5d44f54597da850ce29e2cf","modified":1509176208230},{"_id":"themes/alpha-dust-dk/source/css/_partial/header.styl","hash":"2e1e2ab562719127c7e216a49f8d7c02f9a0c2c4","modified":1509176208230},{"_id":"themes/alpha-dust-dk/source/css/_partial/menu.styl","hash":"746c0bc7b37096b5f0f0a451c4783a054b22c309","modified":1509176208230},{"_id":"themes/alpha-dust-dk/source/css/_partial/pagination.styl","hash":"2368cc9bd2404bce950b55fb2d9be3e7f1e1039c","modified":1509176208230},{"_id":"themes/alpha-dust-dk/source/css/_partial/post-content.styl","hash":"117b655a4f0c78b3cb3fb7be3e09b829c1debc49","modified":1509176208230},{"_id":"themes/alpha-dust-dk/source/css/_partial/post-layout.styl","hash":"b60fbbd78ca88d2174db1426cf941b6c998dd823","modified":1509176208230},{"_id":"themes/alpha-dust-dk/template/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1509176208238},{"_id":"themes/alpha-dust-dk/source/css/_partial/variables.styl","hash":"789108805cf6d536b8a979a722b5b26a7e27fb28","modified":1509176208230},{"_id":"themes/alpha-dust-dk/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1509176208214},{"_id":"themes/alpha-dust-dk/.git/logs/refs/heads/master","hash":"59a0b96aa6bb45fb340c2eaa01a916d5240b5db6","modified":1509176208214},{"_id":"themes/alpha-dust-dk/template/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1509176208234},{"_id":"themes/alpha-dust-dk/.git/logs/refs/remotes/origin/HEAD","hash":"59a0b96aa6bb45fb340c2eaa01a916d5240b5db6","modified":1509176208214},{"_id":"themes/alpha-dust-dk/.git/objects/pack/pack-cc02715080c97efacf3052cc5738c1b12ba175bf.pack","hash":"1e39acce45efefb48183aaf03cd0dfbca970a27e","modified":1509176208206},{"_id":"public/about.html","hash":"8690e699550e79ff181e5ce6bb5f2421fbd7c16b","modified":1512615561879},{"_id":"public/contact.html","hash":"6626fe8a54bf18bef4d6272bf1d4f100a6c9de2a","modified":1512615561891},{"_id":"public/categories/index.html","hash":"4333d30b0c3e42d08c1fe6b346fde5d959fdee98","modified":1512615561892},{"_id":"public/tags/index.html","hash":"d0616c187a04007a2fcc274a4104e6997431047b","modified":1512615561892},{"_id":"public/2017/12/04/small things/index.html","hash":"5c055427f38ee998fa2146cb72890919ec87f3c8","modified":1512615561892},{"_id":"public/archives/index.html","hash":"fa8256acf96c125280098ba560a7f977861c0a3e","modified":1512615561893},{"_id":"public/archives/2017/index.html","hash":"7c16c98b54f30a951abc36f8cf5051f89e57511d","modified":1512615561893},{"_id":"public/2017/10/24/opentk-manual/index.html","hash":"c9dd05245800ebaa0ad5e8cf92db69cf48696e34","modified":1512615561892},{"_id":"public/index.html","hash":"21cd4d40f3fecca3cfbb43c646169e30737244d2","modified":1512615561897},{"_id":"public/archives/2017/12/index.html","hash":"ee63b42149eb87b6ad1e7ba591014401a0c5941a","modified":1512615561897},{"_id":"public/archives/2017/10/index.html","hash":"85cc4ae58311d6be2e444675eb1e84b60f4996f5","modified":1512615561894},{"_id":"public/tags/C/index.html","hash":"4404485bebff6c01e152f7295fcbf76dbb713936","modified":1512615561892},{"_id":"public/2017/12/04/mono-on-Linux manual/index.html","hash":"96eaddf43f5bb585c464a58669aa7194b448cefc","modified":1512615561894},{"_id":"public/tags/OpenTK/index.html","hash":"9204a3c1d79cb4a82a495e2cf5e6d3a3a882ad83","modified":1512615561892},{"_id":"public/tags/Mono/index.html","hash":"d0081cf95e7e1c0f2f026786a072b335140ec876","modified":1512615561892},{"_id":"public/tags/Linux/index.html","hash":"d6f8b1ebe12ddb276c715e7131de7f6762e516c3","modified":1512615561893},{"_id":"public/2017/12/05/csharp-metaprogramming/index.html","hash":"31ce312dfc95221a26f3e3871d26ca1ea2ec16b7","modified":1512480662670},{"_id":"public/img/bg-pattern.png","hash":"932374ff0b431bf83d092948e1714d90254dd92e","modified":1512480662670},{"_id":"public/js/main.js","hash":"7ee829ab42cf4d81280d20b5d664759436b19075","modified":1512480664160},{"_id":"public/css/style.css","hash":"a8b4312a0a6e600e3c1629df20e2860757370d10","modified":1512480664162},{"_id":"source/_posts/csharp-reflection.md","hash":"5cc6a1c34ffa7f694361f45f29d5e33d972021a9","modified":1512614447424},{"_id":"public/2017/12/05/csharp-reflection/index.html","hash":"cc8294c9db0b03124ee31b376870f8ec7cb99861","modified":1512615561897}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2017-10-24T07:33:17.000Z","tags":["about"],"_content":"DK 的 ID 是 DragoonKiller.  这个 ID 从初中开始一直用到现在, 虽然它的英文意义有点奇怪但是我也用习惯了就不改了...  \n退役 OIer, 现役(即将退役) ACMer, 华中科技大学软件工程专业, 联创团队 Game 组.","source":"about.md","raw":"---\ntitle: about\ndate: 2017-10-24 15:33:17\ntags:\n- about\n---\nDK 的 ID 是 DragoonKiller.  这个 ID 从初中开始一直用到现在, 虽然它的英文意义有点奇怪但是我也用习惯了就不改了...  \n退役 OIer, 现役(即将退役) ACMer, 华中科技大学软件工程专业, 联创团队 Game 组.","updated":"2017-10-28T07:33:30.457Z","path":"about.html","comments":1,"layout":"page","_id":"cjatnxnim0000nhmp7xtfhaiu","content":"<p>DK 的 ID 是 DragoonKiller.  这个 ID 从初中开始一直用到现在, 虽然它的英文意义有点奇怪但是我也用习惯了就不改了…<br>退役 OIer, 现役(即将退役) ACMer, 华中科技大学软件工程专业, 联创团队 Game 组.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>DK 的 ID 是 DragoonKiller.  这个 ID 从初中开始一直用到现在, 虽然它的英文意义有点奇怪但是我也用习惯了就不改了…<br>退役 OIer, 现役(即将退役) ACMer, 华中科技大学软件工程专业, 联创团队 Game 组.</p>\n"},{"title":"about","date":"2017-10-24T07:33:17.000Z","tags":null,"_content":"","source":"contact.md","raw":"---\ntitle: about\ndate: 2017-10-24 15:33:17\ntags:\n---\n","updated":"2017-10-28T07:33:30.457Z","path":"contact.html","comments":1,"layout":"page","_id":"cjatnxnit0001nhmpfpbdlhxs","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ntype: \"categories\"\n---\n","date":"2017-10-28T11:35:02.935Z","updated":"2017-10-28T07:33:30.457Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjatnxnms0008nhmp8ytz1gzp","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"All tags","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: All tags\ntype: \"tags\"\n---\n","date":"2017-10-28T11:35:02.938Z","updated":"2017-10-28T07:33:30.457Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjatnxnmz000anhmpo1jhhmo9","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"OpenTK 入门指南","date":"2017-10-24T12:26:25.000Z","_content":"\nOpenTK 是C#对 OpenGL, OpenAL 和 OpenCL 的封装.  \n这里只讲 OpenTK 基础用法, 以及简要介绍其中一些组件, 不教以上三套API.\n\n<!-- more -->\n\n从网上下载OpenTK源代码然后编译得到一个`OpenTK.dll`.  \n在工程中引用它:\n```xml\n<ItemGroup>\n...\n    <Reference Include=\"System.Drawing\" />\n    <Reference Include=\"OpenTK\">\n        <HintPath>./lib/OpenTK.dll<HintPath>\n    </Reference>\n...\n</ItemGroup>\n```\n注意 `System.Drawing` 是OpenTK的一个依赖库.  \n如果你不喜欢用工程文件而更喜欢手动编译, 那么也可以:\n```\nmcs ... ... -reference:./OpenTK.dll\n```\n然后就可以开始写代码了.\n\n\n```CSharp\nusing OpenTK;\nusing OpenTK.Graphics;\nusing OpenTK.Graphics.OpenGL;\nusing System.Drawing;\n```\nOpenTK实际上自己搞了一个和 GLFW 差不多的东西, 不过使用了一些C#自己的特性(比如委托和事件), 用法大概是这样:\n```CSharp\n...\n    GameWindow window = new GameWindow(1024,768, ...);\n    window.MakeCurrent();\n    window.Viewport(0, 0, 1024, 768);\n    \n    window.UpdateFrame += (object s, FrameEventArgs e) =>\n    {\n        window.ProcessEvents();\n        // ...\n        // 核心逻辑...\n        // ...\n    };\n    \n    window.RenderFrame += (object s, FrameEvertArgs e) =>\n    {\n        // ...\n        // 做一些绘制工作...\n        // ...\n        window.SwapBuffers();\n    };\n    \n    window.Run(60, 60);\n...\n```\n然后你会发现一件事情, 那就是如果没有自动补全你写代码的感受和c++差不多, 但是有了自动补全之后就变得非常快~\\\\(≧▽≦)/~  \n\nOpenTK 内置了一些枚举类型用来替代 C 语言的 OpenGL 那个恶心人的 GLenum. (C 语言没有枚举类型咯 ???...). 举几个例子:\n```CSharp\n    GL.BufferData(BufferTarget.ArrayBuffer, data.Length * sizeof(float), data, BufferUsageHint.StaticDraw);\n\n    GL.VertexAttribPointer(0, 2, VertexAttribPointerType.Float, false, sizeof(float) * 2, 0);\n    \n    int vert = GL.CreateShader(ShaderType.VertexShader);\n    \n    GL.DrawArrays(PrimitiveType.TriangleStrip, 0, 3);\n```\n\n虽然代码变得更长了.... 但是有自动补全这显然不是什么大问题.....\n","source":"_posts/opentk-manual.md","raw":"---\ntitle: OpenTK 入门指南\ndate: 2017-10-24 20:26:25\ntags:\n- C#\n- OpenTK\n---\n\nOpenTK 是C#对 OpenGL, OpenAL 和 OpenCL 的封装.  \n这里只讲 OpenTK 基础用法, 以及简要介绍其中一些组件, 不教以上三套API.\n\n<!-- more -->\n\n从网上下载OpenTK源代码然后编译得到一个`OpenTK.dll`.  \n在工程中引用它:\n```xml\n<ItemGroup>\n...\n    <Reference Include=\"System.Drawing\" />\n    <Reference Include=\"OpenTK\">\n        <HintPath>./lib/OpenTK.dll<HintPath>\n    </Reference>\n...\n</ItemGroup>\n```\n注意 `System.Drawing` 是OpenTK的一个依赖库.  \n如果你不喜欢用工程文件而更喜欢手动编译, 那么也可以:\n```\nmcs ... ... -reference:./OpenTK.dll\n```\n然后就可以开始写代码了.\n\n\n```CSharp\nusing OpenTK;\nusing OpenTK.Graphics;\nusing OpenTK.Graphics.OpenGL;\nusing System.Drawing;\n```\nOpenTK实际上自己搞了一个和 GLFW 差不多的东西, 不过使用了一些C#自己的特性(比如委托和事件), 用法大概是这样:\n```CSharp\n...\n    GameWindow window = new GameWindow(1024,768, ...);\n    window.MakeCurrent();\n    window.Viewport(0, 0, 1024, 768);\n    \n    window.UpdateFrame += (object s, FrameEventArgs e) =>\n    {\n        window.ProcessEvents();\n        // ...\n        // 核心逻辑...\n        // ...\n    };\n    \n    window.RenderFrame += (object s, FrameEvertArgs e) =>\n    {\n        // ...\n        // 做一些绘制工作...\n        // ...\n        window.SwapBuffers();\n    };\n    \n    window.Run(60, 60);\n...\n```\n然后你会发现一件事情, 那就是如果没有自动补全你写代码的感受和c++差不多, 但是有了自动补全之后就变得非常快~\\\\(≧▽≦)/~  \n\nOpenTK 内置了一些枚举类型用来替代 C 语言的 OpenGL 那个恶心人的 GLenum. (C 语言没有枚举类型咯 ???...). 举几个例子:\n```CSharp\n    GL.BufferData(BufferTarget.ArrayBuffer, data.Length * sizeof(float), data, BufferUsageHint.StaticDraw);\n\n    GL.VertexAttribPointer(0, 2, VertexAttribPointerType.Float, false, sizeof(float) * 2, 0);\n    \n    int vert = GL.CreateShader(ShaderType.VertexShader);\n    \n    GL.DrawArrays(PrimitiveType.TriangleStrip, 0, 3);\n```\n\n虽然代码变得更长了.... 但是有自动补全这显然不是什么大问题.....\n","slug":"opentk-manual","published":1,"updated":"2017-10-28T07:33:30.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjatnxnm20003nhmpg3clwr38","content":"<p>OpenTK 是C#对 OpenGL, OpenAL 和 OpenCL 的封装.<br>这里只讲 OpenTK 基础用法, 以及简要介绍其中一些组件, 不教以上三套API.</p>\n<a id=\"more\"></a>\n<p>从网上下载OpenTK源代码然后编译得到一个<code>OpenTK.dll</code>.<br>在工程中引用它:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ItemGroup</span>&gt;</span></div><div class=\"line\">...</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Reference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"System.Drawing\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Reference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"OpenTK\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">HintPath</span>&gt;</span>./lib/OpenTK.dll<span class=\"tag\">&lt;<span class=\"name\">HintPath</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">Reference</span>&gt;</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ItemGroup</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>注意 <code>System.Drawing</code> 是OpenTK的一个依赖库.<br>如果你不喜欢用工程文件而更喜欢手动编译, 那么也可以:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mcs ... ... -reference:./OpenTK.dll</div></pre></td></tr></table></figure></p>\n<p>然后就可以开始写代码了.</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">using</span> OpenTK;</div><div class=\"line\"><span class=\"keyword\">using</span> OpenTK.Graphics;</div><div class=\"line\"><span class=\"keyword\">using</span> OpenTK.Graphics.OpenGL;</div><div class=\"line\"><span class=\"keyword\">using</span> System.Drawing;</div></pre></td></tr></table></figure>\n<p>OpenTK实际上自己搞了一个和 GLFW 差不多的东西, 不过使用了一些C#自己的特性(比如委托和事件), 用法大概是这样:<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">    GameWindow window = <span class=\"keyword\">new</span> GameWindow(<span class=\"number\">1024</span>,<span class=\"number\">768</span>, ...);</div><div class=\"line\">    window.MakeCurrent();</div><div class=\"line\">    window.Viewport(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1024</span>, <span class=\"number\">768</span>);</div><div class=\"line\">    </div><div class=\"line\">    window.UpdateFrame += (<span class=\"keyword\">object</span> s, FrameEventArgs e) =&gt;</div><div class=\"line\">    &#123;</div><div class=\"line\">        window.ProcessEvents();</div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">        <span class=\"comment\">// 核心逻辑...</span></div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    window.RenderFrame += (<span class=\"keyword\">object</span> s, FrameEvertArgs e) =&gt;</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">        <span class=\"comment\">// 做一些绘制工作...</span></div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">        window.SwapBuffers();</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    window.Run(<span class=\"number\">60</span>, <span class=\"number\">60</span>);</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<p>然后你会发现一件事情, 那就是如果没有自动补全你写代码的感受和c++差不多, 但是有了自动补全之后就变得非常快~\\(≧▽≦)/~  </p>\n<p>OpenTK 内置了一些枚举类型用来替代 C 语言的 OpenGL 那个恶心人的 GLenum. (C 语言没有枚举类型咯 ???…). 举几个例子:<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">GL.BufferData(BufferTarget.ArrayBuffer, data.Length * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">float</span>), data, BufferUsageHint.StaticDraw);</div><div class=\"line\"></div><div class=\"line\">GL.VertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">2</span>, VertexAttribPointerType.Float, <span class=\"literal\">false</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">float</span>) * <span class=\"number\">2</span>, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> vert = GL.CreateShader(ShaderType.VertexShader);</div><div class=\"line\"></div><div class=\"line\">GL.DrawArrays(PrimitiveType.TriangleStrip, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div></pre></td></tr></table></figure></p>\n<p>虽然代码变得更长了…. 但是有自动补全这显然不是什么大问题…..</p>\n","site":{"data":{}},"excerpt":"<p>OpenTK 是C#对 OpenGL, OpenAL 和 OpenCL 的封装.<br>这里只讲 OpenTK 基础用法, 以及简要介绍其中一些组件, 不教以上三套API.</p>","more":"<p>从网上下载OpenTK源代码然后编译得到一个<code>OpenTK.dll</code>.<br>在工程中引用它:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ItemGroup</span>&gt;</span></div><div class=\"line\">...</div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Reference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"System.Drawing\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Reference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"OpenTK\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">HintPath</span>&gt;</span>./lib/OpenTK.dll<span class=\"tag\">&lt;<span class=\"name\">HintPath</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">Reference</span>&gt;</span></div><div class=\"line\">...</div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ItemGroup</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>注意 <code>System.Drawing</code> 是OpenTK的一个依赖库.<br>如果你不喜欢用工程文件而更喜欢手动编译, 那么也可以:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mcs ... ... -reference:./OpenTK.dll</div></pre></td></tr></table></figure></p>\n<p>然后就可以开始写代码了.</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">using</span> OpenTK;</div><div class=\"line\"><span class=\"keyword\">using</span> OpenTK.Graphics;</div><div class=\"line\"><span class=\"keyword\">using</span> OpenTK.Graphics.OpenGL;</div><div class=\"line\"><span class=\"keyword\">using</span> System.Drawing;</div></pre></td></tr></table></figure>\n<p>OpenTK实际上自己搞了一个和 GLFW 差不多的东西, 不过使用了一些C#自己的特性(比如委托和事件), 用法大概是这样:<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">    GameWindow window = <span class=\"keyword\">new</span> GameWindow(<span class=\"number\">1024</span>,<span class=\"number\">768</span>, ...);</div><div class=\"line\">    window.MakeCurrent();</div><div class=\"line\">    window.Viewport(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1024</span>, <span class=\"number\">768</span>);</div><div class=\"line\">    </div><div class=\"line\">    window.UpdateFrame += (<span class=\"keyword\">object</span> s, FrameEventArgs e) =&gt;</div><div class=\"line\">    &#123;</div><div class=\"line\">        window.ProcessEvents();</div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">        <span class=\"comment\">// 核心逻辑...</span></div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    window.RenderFrame += (<span class=\"keyword\">object</span> s, FrameEvertArgs e) =&gt;</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">        <span class=\"comment\">// 做一些绘制工作...</span></div><div class=\"line\">        <span class=\"comment\">// ...</span></div><div class=\"line\">        window.SwapBuffers();</div><div class=\"line\">    &#125;;</div><div class=\"line\">    </div><div class=\"line\">    window.Run(<span class=\"number\">60</span>, <span class=\"number\">60</span>);</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<p>然后你会发现一件事情, 那就是如果没有自动补全你写代码的感受和c++差不多, 但是有了自动补全之后就变得非常快~\\(≧▽≦)/~  </p>\n<p>OpenTK 内置了一些枚举类型用来替代 C 语言的 OpenGL 那个恶心人的 GLenum. (C 语言没有枚举类型咯 ???…). 举几个例子:<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">GL.BufferData(BufferTarget.ArrayBuffer, data.Length * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">float</span>), data, BufferUsageHint.StaticDraw);</div><div class=\"line\"></div><div class=\"line\">GL.VertexAttribPointer(<span class=\"number\">0</span>, <span class=\"number\">2</span>, VertexAttribPointerType.Float, <span class=\"literal\">false</span>, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">float</span>) * <span class=\"number\">2</span>, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> vert = GL.CreateShader(ShaderType.VertexShader);</div><div class=\"line\"></div><div class=\"line\">GL.DrawArrays(PrimitiveType.TriangleStrip, <span class=\"number\">0</span>, <span class=\"number\">3</span>);</div></pre></td></tr></table></figure></p>\n<p>虽然代码变得更长了…. 但是有自动补全这显然不是什么大问题…..</p>"},{"title":"C#/Mono on Linux 入门指南","date":"2017-12-04T15:57:55.000Z","_content":"\n教你如何在 Linux 上耍 C#.\n\n**注意:** 如果你选择 MonoDevelop, 那么这篇文章绝大部分对你没有用处.  作为一个vscode选手, 折腾一下这种东西还是有必要的.\n\n<!-- more -->\n\n#### 安装 Mono (不是 MonoDevelop)\n\n全家桶:\n```bash\nsudo aptitude install mono-complete\n```\n\n运行时:\n```\nsudo aptitude install mono-runtime\n```\n\n### 编译C#源程序\n编译一个文件, 默认输出为可执行文件. 注意虽然输出的可执行文件后缀名是 `exe`, 但是它是可以在 linux 下跑的...\n```\nmcs ./x.cs\n```\n \n指定输出文件名:\n```\nmcs ./x.cs -out:a.exe\n```\n注意冒号不能省, 在windows下参数以斜杠 / 开头不过 mono 两者都能用.\n\n可以使用正则匹配.\n```\nmcs ./*.cs -out:a.exe\n```\n想链接外部.Net库(通常是**编译成IL的**dll文件):\n```\nmcs ./*.cs -out:a.exe -resource:./OpenTK.dll\n```\n使用相对路径. 使用此方法生成的程序(*.exe)需要和依赖库放在同一目录下, 即使编译时它们处于不同目录下.\n\n如果不想把源程序编译成可执行代码, 而是编译成一个dll, 可以:\n```\nmcs ./*.cs -target:library -out:x.dll\n```\n\n### 运行C#程序\n\n使用 mono 运行时:\n```\nmono ./x.exe\n```\n\n似乎在某些情况下可以直接运行:\n```\n./x.exe\n```\n\n### C#工程文件\n\n微软自家的工程以解决方案(Solution)为最顶层的元素.  \n一个解决方案包含至少一个项目(Project).  \n\n项目是基本的编译单元, 一般来说一个项目产生一个dll/exe, 但是你可以自定义编译链接流程来执行一些奇怪的操作.(并不确定真的是这样)  \n\n工程文件, 例如 x.csproj, 内容大概长这样:\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  \n  <PropertyGroup>\n    <OutputType>exe</OutputType>\n    <OutputPath>./bin</OutputPath>\n    <AssemblyName>Tokamach</AssemblyName>\n    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>\n    <FileAlignment>512</FileAlignment>\n  </PropertyGroup>\n  \n  <ItemGroup>\n    <Compile Include=\"./src/*.cs\" />\n    <Compile Include=\"./src/Graphics/*.cs\" />\n    <Reference Include=\"System\" />\n    <Reference Include=\"System.Drawing\" />\n    <Reference Include=\"OpenTK\">\n      <HintPath>./lib/OpenTK.dll</HintPath>\n    </Reference>\n  </ItemGroup>\n  \n  <Import Project=\"$(MSBuildToolsPath)\\Microsoft.CSharp.targets\" />\n</Project>\n```\n注意最后一行` Import` 实际上帮我们配置了一堆默认的 Target. 如果你不想手动配置 Target, 这行不能省略. 如果你使用 OmniSharp, 你需要按照要求配很多个Target, 而且好像并不能查到你需要配哪些 Target 并且需要哪些参数, 所以一般都会直接用这行.\n\n从这个例子中我们可以看到:\n1. 想要添加源文件, 就在ItemGroup里写上`<Compile Include=\"...\" />`.\n1. 支持正则匹配.\n1. 想要链接一个公用的运行时库, 就在ItemGroup里写上`<Reference Include=\"...\" />`.\n1. 如果你的库是从别的地方搞来的, 在ItemGroup里要标记这个库的名称和相对路径, 例如`<Reference Include=\"OpenTK\"><HintPath>./lib/OpenTK.dll</HintPath></Reference>`.\n1. 编译好的exe文件会被直接扔到`<OutputPath>`标签所在路径.\n\n构建工程:\n```\nmsbuild\n```\n如果你的目录里有解决方案文件(.sln文件), 它会读sln文件并构建(Build)其中声明的所有项目. 如果没有, 它会寻找项目文件(.csproj文件, .vcproj文件等)并构建它.\n\n注意, 编译完成以后, 所有外部依赖库文件会被全部拷贝到和目标可执行程序相同目录下(就是`<OutputPath>`指明的路径).\n\n### 调用C/C++的动态库\n首先按照正常方式写一个动态库:\n```cpp\n// a-plus-b.cpp\nextern \"C\" int plus(int a, int b) { return a + b; }\n```\n把它编译成动态库:\n```bash\ngcc ./a-plus-b.cpp -shared -fPIC -o liba-plus-b.so\n```\n上述语句中, `-shared` 表示生成一个动态链接库, `-fPIC` 表示生成\"地址独立\"的函数(呃我也不知道什么意思, 反正是 shared library 必备玩意.)  \n根据 [linux的文档](http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html), 一般我们会把动态链接库放到 `/lib/` 或 `/usr/lib/` . 那么我们把我们的动态链接库拷到 `/usr/lib/` :\n```bash\nsudo cp ./liba-plus-b.so /usr/lib/\n```\n然后就可以使用C#提供的动态链接:\n```CSharp\nusing System.Runtime.InteropServices;\n...\n    [DllImport(\"a-plus-b\")]\n    public static extern int plus(int a, int b);\n...\n```\n然后就可以当普通函数用了.\n\n注意如果在windows环境下, 上面的 C# 程序会搜索 `a-plus-b.dll`, 并且首先搜索程序目录, 其次搜索程序运行目录. 实际上, 尽管 C# 代码不依赖于平台, 你需要为不同的平台提供不同的库文件.\n\n更多详细信息参见 [Mono的文档](http://www.mono-project.com/docs/advanced/pinvoke/).\n\n如果你使用 C++ 的方式编译你的库文件(不加`extern \"C\"`), 你的函数名称会按照某种规则(目前没找到是啥规则...)被修改. 比如我写:\n```cpp\nint plus(int a, int b) { return a + b; }\nint plus(int a, int b, int c) { return a + b + c; }\n```\n可以使用`nm`命令查看动态链接库中的函数名称:\n```bash\nnm -D /usr/lib/liba-plus-b.so\n```\n输出:\n```bash\n...\n0000000000000680 T _Z4plusii\n0000000000000694 T _Z4plusiii\n```\n于是我们可以在我们的C#程序中这样调用函数:\n```CSharp\n[DllImport(\"a-plus-b\")]\npublic static extern int _Z4plusii(int a, int b);\n```\n很丑..\n\n","source":"_posts/mono-on-Linux manual.md","raw":"---\ntitle: C#/Mono on Linux 入门指南\n\ntags:\n- C#\n- Mono\n- Linux\n\ndate: 2017-12-4 23:57:55\n---\n\n教你如何在 Linux 上耍 C#.\n\n**注意:** 如果你选择 MonoDevelop, 那么这篇文章绝大部分对你没有用处.  作为一个vscode选手, 折腾一下这种东西还是有必要的.\n\n<!-- more -->\n\n#### 安装 Mono (不是 MonoDevelop)\n\n全家桶:\n```bash\nsudo aptitude install mono-complete\n```\n\n运行时:\n```\nsudo aptitude install mono-runtime\n```\n\n### 编译C#源程序\n编译一个文件, 默认输出为可执行文件. 注意虽然输出的可执行文件后缀名是 `exe`, 但是它是可以在 linux 下跑的...\n```\nmcs ./x.cs\n```\n \n指定输出文件名:\n```\nmcs ./x.cs -out:a.exe\n```\n注意冒号不能省, 在windows下参数以斜杠 / 开头不过 mono 两者都能用.\n\n可以使用正则匹配.\n```\nmcs ./*.cs -out:a.exe\n```\n想链接外部.Net库(通常是**编译成IL的**dll文件):\n```\nmcs ./*.cs -out:a.exe -resource:./OpenTK.dll\n```\n使用相对路径. 使用此方法生成的程序(*.exe)需要和依赖库放在同一目录下, 即使编译时它们处于不同目录下.\n\n如果不想把源程序编译成可执行代码, 而是编译成一个dll, 可以:\n```\nmcs ./*.cs -target:library -out:x.dll\n```\n\n### 运行C#程序\n\n使用 mono 运行时:\n```\nmono ./x.exe\n```\n\n似乎在某些情况下可以直接运行:\n```\n./x.exe\n```\n\n### C#工程文件\n\n微软自家的工程以解决方案(Solution)为最顶层的元素.  \n一个解决方案包含至少一个项目(Project).  \n\n项目是基本的编译单元, 一般来说一个项目产生一个dll/exe, 但是你可以自定义编译链接流程来执行一些奇怪的操作.(并不确定真的是这样)  \n\n工程文件, 例如 x.csproj, 内容大概长这样:\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  \n  <PropertyGroup>\n    <OutputType>exe</OutputType>\n    <OutputPath>./bin</OutputPath>\n    <AssemblyName>Tokamach</AssemblyName>\n    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>\n    <FileAlignment>512</FileAlignment>\n  </PropertyGroup>\n  \n  <ItemGroup>\n    <Compile Include=\"./src/*.cs\" />\n    <Compile Include=\"./src/Graphics/*.cs\" />\n    <Reference Include=\"System\" />\n    <Reference Include=\"System.Drawing\" />\n    <Reference Include=\"OpenTK\">\n      <HintPath>./lib/OpenTK.dll</HintPath>\n    </Reference>\n  </ItemGroup>\n  \n  <Import Project=\"$(MSBuildToolsPath)\\Microsoft.CSharp.targets\" />\n</Project>\n```\n注意最后一行` Import` 实际上帮我们配置了一堆默认的 Target. 如果你不想手动配置 Target, 这行不能省略. 如果你使用 OmniSharp, 你需要按照要求配很多个Target, 而且好像并不能查到你需要配哪些 Target 并且需要哪些参数, 所以一般都会直接用这行.\n\n从这个例子中我们可以看到:\n1. 想要添加源文件, 就在ItemGroup里写上`<Compile Include=\"...\" />`.\n1. 支持正则匹配.\n1. 想要链接一个公用的运行时库, 就在ItemGroup里写上`<Reference Include=\"...\" />`.\n1. 如果你的库是从别的地方搞来的, 在ItemGroup里要标记这个库的名称和相对路径, 例如`<Reference Include=\"OpenTK\"><HintPath>./lib/OpenTK.dll</HintPath></Reference>`.\n1. 编译好的exe文件会被直接扔到`<OutputPath>`标签所在路径.\n\n构建工程:\n```\nmsbuild\n```\n如果你的目录里有解决方案文件(.sln文件), 它会读sln文件并构建(Build)其中声明的所有项目. 如果没有, 它会寻找项目文件(.csproj文件, .vcproj文件等)并构建它.\n\n注意, 编译完成以后, 所有外部依赖库文件会被全部拷贝到和目标可执行程序相同目录下(就是`<OutputPath>`指明的路径).\n\n### 调用C/C++的动态库\n首先按照正常方式写一个动态库:\n```cpp\n// a-plus-b.cpp\nextern \"C\" int plus(int a, int b) { return a + b; }\n```\n把它编译成动态库:\n```bash\ngcc ./a-plus-b.cpp -shared -fPIC -o liba-plus-b.so\n```\n上述语句中, `-shared` 表示生成一个动态链接库, `-fPIC` 表示生成\"地址独立\"的函数(呃我也不知道什么意思, 反正是 shared library 必备玩意.)  \n根据 [linux的文档](http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html), 一般我们会把动态链接库放到 `/lib/` 或 `/usr/lib/` . 那么我们把我们的动态链接库拷到 `/usr/lib/` :\n```bash\nsudo cp ./liba-plus-b.so /usr/lib/\n```\n然后就可以使用C#提供的动态链接:\n```CSharp\nusing System.Runtime.InteropServices;\n...\n    [DllImport(\"a-plus-b\")]\n    public static extern int plus(int a, int b);\n...\n```\n然后就可以当普通函数用了.\n\n注意如果在windows环境下, 上面的 C# 程序会搜索 `a-plus-b.dll`, 并且首先搜索程序目录, 其次搜索程序运行目录. 实际上, 尽管 C# 代码不依赖于平台, 你需要为不同的平台提供不同的库文件.\n\n更多详细信息参见 [Mono的文档](http://www.mono-project.com/docs/advanced/pinvoke/).\n\n如果你使用 C++ 的方式编译你的库文件(不加`extern \"C\"`), 你的函数名称会按照某种规则(目前没找到是啥规则...)被修改. 比如我写:\n```cpp\nint plus(int a, int b) { return a + b; }\nint plus(int a, int b, int c) { return a + b + c; }\n```\n可以使用`nm`命令查看动态链接库中的函数名称:\n```bash\nnm -D /usr/lib/liba-plus-b.so\n```\n输出:\n```bash\n...\n0000000000000680 T _Z4plusii\n0000000000000694 T _Z4plusiii\n```\n于是我们可以在我们的C#程序中这样调用函数:\n```CSharp\n[DllImport(\"a-plus-b\")]\npublic static extern int _Z4plusii(int a, int b);\n```\n很丑..\n\n","slug":"mono-on-Linux manual","published":1,"updated":"2017-12-04T14:57:21.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjatnxnmu0009nhmp3r1ts0ix","content":"<p>教你如何在 Linux 上耍 C#.</p>\n<p><strong>注意:</strong> 如果你选择 MonoDevelop, 那么这篇文章绝大部分对你没有用处.  作为一个vscode选手, 折腾一下这种东西还是有必要的.</p>\n<a id=\"more\"></a>\n<h4 id=\"安装-Mono-不是-MonoDevelop\"><a href=\"#安装-Mono-不是-MonoDevelop\" class=\"headerlink\" title=\"安装 Mono (不是 MonoDevelop)\"></a>安装 Mono (不是 MonoDevelop)</h4><p>全家桶:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo aptitude install mono-complete</div></pre></td></tr></table></figure></p>\n<p>运行时:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo aptitude install mono-runtime</div></pre></td></tr></table></figure></p>\n<h3 id=\"编译C-源程序\"><a href=\"#编译C-源程序\" class=\"headerlink\" title=\"编译C#源程序\"></a>编译C#源程序</h3><p>编译一个文件, 默认输出为可执行文件. 注意虽然输出的可执行文件后缀名是 <code>exe</code>, 但是它是可以在 linux 下跑的…<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mcs ./x.cs</div></pre></td></tr></table></figure></p>\n<p>指定输出文件名:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mcs ./x.cs -out:a.exe</div></pre></td></tr></table></figure></p>\n<p>注意冒号不能省, 在windows下参数以斜杠 / 开头不过 mono 两者都能用.</p>\n<p>可以使用正则匹配.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mcs ./*.cs -out:a.exe</div></pre></td></tr></table></figure></p>\n<p>想链接外部.Net库(通常是<strong>编译成IL的</strong>dll文件):<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mcs ./*.cs -out:a.exe -resource:./OpenTK.dll</div></pre></td></tr></table></figure></p>\n<p>使用相对路径. 使用此方法生成的程序(*.exe)需要和依赖库放在同一目录下, 即使编译时它们处于不同目录下.</p>\n<p>如果不想把源程序编译成可执行代码, 而是编译成一个dll, 可以:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mcs ./*.cs -target:library -out:x.dll</div></pre></td></tr></table></figure></p>\n<h3 id=\"运行C-程序\"><a href=\"#运行C-程序\" class=\"headerlink\" title=\"运行C#程序\"></a>运行C#程序</h3><p>使用 mono 运行时:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mono ./x.exe</div></pre></td></tr></table></figure></p>\n<p>似乎在某些情况下可以直接运行:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./x.exe</div></pre></td></tr></table></figure></p>\n<h3 id=\"C-工程文件\"><a href=\"#C-工程文件\" class=\"headerlink\" title=\"C#工程文件\"></a>C#工程文件</h3><p>微软自家的工程以解决方案(Solution)为最顶层的元素.<br>一个解决方案包含至少一个项目(Project).  </p>\n<p>项目是基本的编译单元, 一般来说一个项目产生一个dll/exe, 但是你可以自定义编译链接流程来执行一些奇怪的操作.(并不确定真的是这样)  </p>\n<p>工程文件, 例如 x.csproj, 内容大概长这样:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Project</span> <span class=\"attr\">DefaultTargets</span>=<span class=\"string\">\"Build\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://schemas.microsoft.com/developer/msbuild/2003\"</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">PropertyGroup</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">OutputType</span>&gt;</span>exe<span class=\"tag\">&lt;/<span class=\"name\">OutputType</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">OutputPath</span>&gt;</span>./bin<span class=\"tag\">&lt;/<span class=\"name\">OutputPath</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">AssemblyName</span>&gt;</span>Tokamach<span class=\"tag\">&lt;/<span class=\"name\">AssemblyName</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">TargetFrameworkVersion</span>&gt;</span>v3.5<span class=\"tag\">&lt;/<span class=\"name\">TargetFrameworkVersion</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">FileAlignment</span>&gt;</span>512<span class=\"tag\">&lt;/<span class=\"name\">FileAlignment</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">PropertyGroup</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ItemGroup</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Compile</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"./src/*.cs\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Compile</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"./src/Graphics/*.cs\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Reference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"System\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Reference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"System.Drawing\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Reference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"OpenTK\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">HintPath</span>&gt;</span>./lib/OpenTK.dll<span class=\"tag\">&lt;/<span class=\"name\">HintPath</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">Reference</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ItemGroup</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">Import</span> <span class=\"attr\">Project</span>=<span class=\"string\">\"$(MSBuildToolsPath)\\Microsoft.CSharp.targets\"</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Project</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>注意最后一行<code>Import</code> 实际上帮我们配置了一堆默认的 Target. 如果你不想手动配置 Target, 这行不能省略. 如果你使用 OmniSharp, 你需要按照要求配很多个Target, 而且好像并不能查到你需要配哪些 Target 并且需要哪些参数, 所以一般都会直接用这行.</p>\n<p>从这个例子中我们可以看到:</p>\n<ol>\n<li>想要添加源文件, 就在ItemGroup里写上<code>&lt;Compile Include=&quot;...&quot; /&gt;</code>.</li>\n<li>支持正则匹配.</li>\n<li>想要链接一个公用的运行时库, 就在ItemGroup里写上<code>&lt;Reference Include=&quot;...&quot; /&gt;</code>.</li>\n<li>如果你的库是从别的地方搞来的, 在ItemGroup里要标记这个库的名称和相对路径, 例如<code>&lt;Reference Include=&quot;OpenTK&quot;&gt;&lt;HintPath&gt;./lib/OpenTK.dll&lt;/HintPath&gt;&lt;/Reference&gt;</code>.</li>\n<li>编译好的exe文件会被直接扔到<code>&lt;OutputPath&gt;</code>标签所在路径.</li>\n</ol>\n<p>构建工程:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">msbuild</div></pre></td></tr></table></figure></p>\n<p>如果你的目录里有解决方案文件(.sln文件), 它会读sln文件并构建(Build)其中声明的所有项目. 如果没有, 它会寻找项目文件(.csproj文件, .vcproj文件等)并构建它.</p>\n<p>注意, 编译完成以后, 所有外部依赖库文件会被全部拷贝到和目标可执行程序相同目录下(就是<code>&lt;OutputPath&gt;</code>指明的路径).</p>\n<h3 id=\"调用C-C-的动态库\"><a href=\"#调用C-C-的动态库\" class=\"headerlink\" title=\"调用C/C++的动态库\"></a>调用C/C++的动态库</h3><p>首先按照正常方式写一个动态库:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// a-plus-b.cpp</span></div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">plus</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a + b; &#125;</div></pre></td></tr></table></figure></p>\n<p>把它编译成动态库:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gcc ./a-plus-b.cpp -shared -fPIC -o liba-plus-b.so</div></pre></td></tr></table></figure></p>\n<p>上述语句中, <code>-shared</code> 表示生成一个动态链接库, <code>-fPIC</code> 表示生成”地址独立”的函数(呃我也不知道什么意思, 反正是 shared library 必备玩意.)<br>根据 <a href=\"http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html\" target=\"_blank\" rel=\"external\">linux的文档</a>, 一般我们会把动态链接库放到 <code>/lib/</code> 或 <code>/usr/lib/</code> . 那么我们把我们的动态链接库拷到 <code>/usr/lib/</code> :<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo cp ./liba-plus-b.so /usr/lib/</div></pre></td></tr></table></figure></p>\n<p>然后就可以使用C#提供的动态链接:<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">using</span> System.Runtime.InteropServices;</div><div class=\"line\">...</div><div class=\"line\">    [<span class=\"meta\">DllImport(<span class=\"meta-string\">\"a-plus-b\"</span>)</span>]</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> <span class=\"title\">plus</span>(<span class=\"params\"><span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b</span>)</span>;</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<p>然后就可以当普通函数用了.</p>\n<p>注意如果在windows环境下, 上面的 C# 程序会搜索 <code>a-plus-b.dll</code>, 并且首先搜索程序目录, 其次搜索程序运行目录. 实际上, 尽管 C# 代码不依赖于平台, 你需要为不同的平台提供不同的库文件.</p>\n<p>更多详细信息参见 <a href=\"http://www.mono-project.com/docs/advanced/pinvoke/\" target=\"_blank\" rel=\"external\">Mono的文档</a>.</p>\n<p>如果你使用 C++ 的方式编译你的库文件(不加<code>extern &quot;C&quot;</code>), 你的函数名称会按照某种规则(目前没找到是啥规则…)被修改. 比如我写:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">plus</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a + b; &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">plus</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c)</span> </span>&#123; <span class=\"keyword\">return</span> a + b + c; &#125;</div></pre></td></tr></table></figure></p>\n<p>可以使用<code>nm</code>命令查看动态链接库中的函数名称:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nm -D /usr/lib/liba-plus-b.so</div></pre></td></tr></table></figure></p>\n<p>输出:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">0000000000000680 T _Z4plusii</div><div class=\"line\">0000000000000694 T _Z4plusiii</div></pre></td></tr></table></figure></p>\n<p>于是我们可以在我们的C#程序中这样调用函数:<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"meta\">DllImport(<span class=\"meta-string\">\"a-plus-b\"</span>)</span>]</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> _Z4plusii(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b);</div></pre></td></tr></table></figure></p>\n<p>很丑..</p>\n","site":{"data":{}},"excerpt":"<p>教你如何在 Linux 上耍 C#.</p>\n<p><strong>注意:</strong> 如果你选择 MonoDevelop, 那么这篇文章绝大部分对你没有用处.  作为一个vscode选手, 折腾一下这种东西还是有必要的.</p>","more":"<h4 id=\"安装-Mono-不是-MonoDevelop\"><a href=\"#安装-Mono-不是-MonoDevelop\" class=\"headerlink\" title=\"安装 Mono (不是 MonoDevelop)\"></a>安装 Mono (不是 MonoDevelop)</h4><p>全家桶:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo aptitude install mono-complete</div></pre></td></tr></table></figure></p>\n<p>运行时:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo aptitude install mono-runtime</div></pre></td></tr></table></figure></p>\n<h3 id=\"编译C-源程序\"><a href=\"#编译C-源程序\" class=\"headerlink\" title=\"编译C#源程序\"></a>编译C#源程序</h3><p>编译一个文件, 默认输出为可执行文件. 注意虽然输出的可执行文件后缀名是 <code>exe</code>, 但是它是可以在 linux 下跑的…<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mcs ./x.cs</div></pre></td></tr></table></figure></p>\n<p>指定输出文件名:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mcs ./x.cs -out:a.exe</div></pre></td></tr></table></figure></p>\n<p>注意冒号不能省, 在windows下参数以斜杠 / 开头不过 mono 两者都能用.</p>\n<p>可以使用正则匹配.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mcs ./*.cs -out:a.exe</div></pre></td></tr></table></figure></p>\n<p>想链接外部.Net库(通常是<strong>编译成IL的</strong>dll文件):<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mcs ./*.cs -out:a.exe -resource:./OpenTK.dll</div></pre></td></tr></table></figure></p>\n<p>使用相对路径. 使用此方法生成的程序(*.exe)需要和依赖库放在同一目录下, 即使编译时它们处于不同目录下.</p>\n<p>如果不想把源程序编译成可执行代码, 而是编译成一个dll, 可以:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mcs ./*.cs -target:library -out:x.dll</div></pre></td></tr></table></figure></p>\n<h3 id=\"运行C-程序\"><a href=\"#运行C-程序\" class=\"headerlink\" title=\"运行C#程序\"></a>运行C#程序</h3><p>使用 mono 运行时:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">mono ./x.exe</div></pre></td></tr></table></figure></p>\n<p>似乎在某些情况下可以直接运行:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./x.exe</div></pre></td></tr></table></figure></p>\n<h3 id=\"C-工程文件\"><a href=\"#C-工程文件\" class=\"headerlink\" title=\"C#工程文件\"></a>C#工程文件</h3><p>微软自家的工程以解决方案(Solution)为最顶层的元素.<br>一个解决方案包含至少一个项目(Project).  </p>\n<p>项目是基本的编译单元, 一般来说一个项目产生一个dll/exe, 但是你可以自定义编译链接流程来执行一些奇怪的操作.(并不确定真的是这样)  </p>\n<p>工程文件, 例如 x.csproj, 内容大概长这样:<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Project</span> <span class=\"attr\">DefaultTargets</span>=<span class=\"string\">\"Build\"</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://schemas.microsoft.com/developer/msbuild/2003\"</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">PropertyGroup</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">OutputType</span>&gt;</span>exe<span class=\"tag\">&lt;/<span class=\"name\">OutputType</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">OutputPath</span>&gt;</span>./bin<span class=\"tag\">&lt;/<span class=\"name\">OutputPath</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">AssemblyName</span>&gt;</span>Tokamach<span class=\"tag\">&lt;/<span class=\"name\">AssemblyName</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">TargetFrameworkVersion</span>&gt;</span>v3.5<span class=\"tag\">&lt;/<span class=\"name\">TargetFrameworkVersion</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">FileAlignment</span>&gt;</span>512<span class=\"tag\">&lt;/<span class=\"name\">FileAlignment</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">PropertyGroup</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">ItemGroup</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Compile</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"./src/*.cs\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Compile</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"./src/Graphics/*.cs\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Reference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"System\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Reference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"System.Drawing\"</span> /&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Reference</span> <span class=\"attr\">Include</span>=<span class=\"string\">\"OpenTK\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">HintPath</span>&gt;</span>./lib/OpenTK.dll<span class=\"tag\">&lt;/<span class=\"name\">HintPath</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">Reference</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">ItemGroup</span>&gt;</span></div><div class=\"line\">  </div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">Import</span> <span class=\"attr\">Project</span>=<span class=\"string\">\"$(MSBuildToolsPath)\\Microsoft.CSharp.targets\"</span> /&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Project</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>注意最后一行<code>Import</code> 实际上帮我们配置了一堆默认的 Target. 如果你不想手动配置 Target, 这行不能省略. 如果你使用 OmniSharp, 你需要按照要求配很多个Target, 而且好像并不能查到你需要配哪些 Target 并且需要哪些参数, 所以一般都会直接用这行.</p>\n<p>从这个例子中我们可以看到:</p>\n<ol>\n<li>想要添加源文件, 就在ItemGroup里写上<code>&lt;Compile Include=&quot;...&quot; /&gt;</code>.</li>\n<li>支持正则匹配.</li>\n<li>想要链接一个公用的运行时库, 就在ItemGroup里写上<code>&lt;Reference Include=&quot;...&quot; /&gt;</code>.</li>\n<li>如果你的库是从别的地方搞来的, 在ItemGroup里要标记这个库的名称和相对路径, 例如<code>&lt;Reference Include=&quot;OpenTK&quot;&gt;&lt;HintPath&gt;./lib/OpenTK.dll&lt;/HintPath&gt;&lt;/Reference&gt;</code>.</li>\n<li>编译好的exe文件会被直接扔到<code>&lt;OutputPath&gt;</code>标签所在路径.</li>\n</ol>\n<p>构建工程:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">msbuild</div></pre></td></tr></table></figure></p>\n<p>如果你的目录里有解决方案文件(.sln文件), 它会读sln文件并构建(Build)其中声明的所有项目. 如果没有, 它会寻找项目文件(.csproj文件, .vcproj文件等)并构建它.</p>\n<p>注意, 编译完成以后, 所有外部依赖库文件会被全部拷贝到和目标可执行程序相同目录下(就是<code>&lt;OutputPath&gt;</code>指明的路径).</p>\n<h3 id=\"调用C-C-的动态库\"><a href=\"#调用C-C-的动态库\" class=\"headerlink\" title=\"调用C/C++的动态库\"></a>调用C/C++的动态库</h3><p>首先按照正常方式写一个动态库:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// a-plus-b.cpp</span></div><div class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">plus</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a + b; &#125;</div></pre></td></tr></table></figure></p>\n<p>把它编译成动态库:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gcc ./a-plus-b.cpp -shared -fPIC -o liba-plus-b.so</div></pre></td></tr></table></figure></p>\n<p>上述语句中, <code>-shared</code> 表示生成一个动态链接库, <code>-fPIC</code> 表示生成”地址独立”的函数(呃我也不知道什么意思, 反正是 shared library 必备玩意.)<br>根据 <a href=\"http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html\" target=\"_blank\" rel=\"external\">linux的文档</a>, 一般我们会把动态链接库放到 <code>/lib/</code> 或 <code>/usr/lib/</code> . 那么我们把我们的动态链接库拷到 <code>/usr/lib/</code> :<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo cp ./liba-plus-b.so /usr/lib/</div></pre></td></tr></table></figure></p>\n<p>然后就可以使用C#提供的动态链接:<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">using</span> System.Runtime.InteropServices;</div><div class=\"line\">...</div><div class=\"line\">    [<span class=\"meta\">DllImport(<span class=\"meta-string\">\"a-plus-b\"</span>)</span>]</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> <span class=\"title\">plus</span>(<span class=\"params\"><span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b</span>)</span>;</div><div class=\"line\">...</div></pre></td></tr></table></figure></p>\n<p>然后就可以当普通函数用了.</p>\n<p>注意如果在windows环境下, 上面的 C# 程序会搜索 <code>a-plus-b.dll</code>, 并且首先搜索程序目录, 其次搜索程序运行目录. 实际上, 尽管 C# 代码不依赖于平台, 你需要为不同的平台提供不同的库文件.</p>\n<p>更多详细信息参见 <a href=\"http://www.mono-project.com/docs/advanced/pinvoke/\" target=\"_blank\" rel=\"external\">Mono的文档</a>.</p>\n<p>如果你使用 C++ 的方式编译你的库文件(不加<code>extern &quot;C&quot;</code>), 你的函数名称会按照某种规则(目前没找到是啥规则…)被修改. 比如我写:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">plus</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123; <span class=\"keyword\">return</span> a + b; &#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">plus</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b, <span class=\"keyword\">int</span> c)</span> </span>&#123; <span class=\"keyword\">return</span> a + b + c; &#125;</div></pre></td></tr></table></figure></p>\n<p>可以使用<code>nm</code>命令查看动态链接库中的函数名称:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">nm -D /usr/lib/liba-plus-b.so</div></pre></td></tr></table></figure></p>\n<p>输出:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">0000000000000680 T _Z4plusii</div><div class=\"line\">0000000000000694 T _Z4plusiii</div></pre></td></tr></table></figure></p>\n<p>于是我们可以在我们的C#程序中这样调用函数:<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[<span class=\"meta\">DllImport(<span class=\"meta-string\">\"a-plus-b\"</span>)</span>]</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> _Z4plusii(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b);</div></pre></td></tr></table></figure></p>\n<p>很丑..</p>"},{"title":"小记, 一些琐碎的东西","date":"2017-12-04T15:51:12.000Z","_content":"\n记录一些非常重要, 但是并不值得开一篇文章大谈特谈的坑.\n\n<!-- more -->\n\n1. github page 的repo名称如果不设置为 [your_name].github.io 会被认为是项目 page , 会使用 Jekyll 来组织页面. 然后 hexo 推上去就会报错. mdzz.\n\n1. 如果你配置 vscode-OmniSharp 发现工程文件无法读取, 那可能是你的电脑安装的 OmniSharp 版本太老或者有 Bug . 我用 Ubuntu 16.04 LTS 上的 apt-get 下载安装的 OmniSharp 恰好是那个出问题的版本(啊这群维护repo的在想什么). 去官网下载一个新的, 直接make, 就能解决问题了.\n\n1. hexo 文章在首页的截断符是`<!-- more -->`, 注意空格, 注意空格, 注意空格.\n\n1. C# 的迭代器是左开右闭. C++ 是左闭右开. \n\n1. MSBuild 里的通配符 `**` 表示部分路径, `*` 表示零个或多个字符. 想要匹配目录 `Project` 及其子目录下的所有 `.cs` 文件, 可以这么写 `Project/**/*.cs`. [参见这个网页.](https://stackoverflow.com/questions/8532929/two-asterisks-in-file-path) ","source":"_posts/small things.md","raw":"---\ntitle: '小记, 一些琐碎的东西'\ndate: 2017-12-4 23:51:12\ntags:\n---\n\n记录一些非常重要, 但是并不值得开一篇文章大谈特谈的坑.\n\n<!-- more -->\n\n1. github page 的repo名称如果不设置为 [your_name].github.io 会被认为是项目 page , 会使用 Jekyll 来组织页面. 然后 hexo 推上去就会报错. mdzz.\n\n1. 如果你配置 vscode-OmniSharp 发现工程文件无法读取, 那可能是你的电脑安装的 OmniSharp 版本太老或者有 Bug . 我用 Ubuntu 16.04 LTS 上的 apt-get 下载安装的 OmniSharp 恰好是那个出问题的版本(啊这群维护repo的在想什么). 去官网下载一个新的, 直接make, 就能解决问题了.\n\n1. hexo 文章在首页的截断符是`<!-- more -->`, 注意空格, 注意空格, 注意空格.\n\n1. C# 的迭代器是左开右闭. C++ 是左闭右开. \n\n1. MSBuild 里的通配符 `**` 表示部分路径, `*` 表示零个或多个字符. 想要匹配目录 `Project` 及其子目录下的所有 `.cs` 文件, 可以这么写 `Project/**/*.cs`. [参见这个网页.](https://stackoverflow.com/questions/8532929/two-asterisks-in-file-path) ","slug":"small things","published":1,"updated":"2017-12-04T14:51:45.341Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjatnxnn2000bnhmpr77v1vgg","content":"<p>记录一些非常重要, 但是并不值得开一篇文章大谈特谈的坑.</p>\n<a id=\"more\"></a>\n<ol>\n<li><p>github page 的repo名称如果不设置为 [your_name].github.io 会被认为是项目 page , 会使用 Jekyll 来组织页面. 然后 hexo 推上去就会报错. mdzz.</p>\n</li>\n<li><p>如果你配置 vscode-OmniSharp 发现工程文件无法读取, 那可能是你的电脑安装的 OmniSharp 版本太老或者有 Bug . 我用 Ubuntu 16.04 LTS 上的 apt-get 下载安装的 OmniSharp 恰好是那个出问题的版本(啊这群维护repo的在想什么). 去官网下载一个新的, 直接make, 就能解决问题了.</p>\n</li>\n<li><p>hexo 文章在首页的截断符是<code>&lt;!-- more --&gt;</code>, 注意空格, 注意空格, 注意空格.</p>\n</li>\n<li><p>C# 的迭代器是左开右闭. C++ 是左闭右开. </p>\n</li>\n<li><p>MSBuild 里的通配符 <code>**</code> 表示部分路径, <code>*</code> 表示零个或多个字符. 想要匹配目录 <code>Project</code> 及其子目录下的所有 <code>.cs</code> 文件, 可以这么写 <code>Project/**/*.cs</code>. <a href=\"https://stackoverflow.com/questions/8532929/two-asterisks-in-file-path\" target=\"_blank\" rel=\"external\">参见这个网页.</a> </p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>记录一些非常重要, 但是并不值得开一篇文章大谈特谈的坑.</p>","more":"<ol>\n<li><p>github page 的repo名称如果不设置为 [your_name].github.io 会被认为是项目 page , 会使用 Jekyll 来组织页面. 然后 hexo 推上去就会报错. mdzz.</p>\n</li>\n<li><p>如果你配置 vscode-OmniSharp 发现工程文件无法读取, 那可能是你的电脑安装的 OmniSharp 版本太老或者有 Bug . 我用 Ubuntu 16.04 LTS 上的 apt-get 下载安装的 OmniSharp 恰好是那个出问题的版本(啊这群维护repo的在想什么). 去官网下载一个新的, 直接make, 就能解决问题了.</p>\n</li>\n<li><p>hexo 文章在首页的截断符是<code>&lt;!-- more --&gt;</code>, 注意空格, 注意空格, 注意空格.</p>\n</li>\n<li><p>C# 的迭代器是左开右闭. C++ 是左闭右开. </p>\n</li>\n<li><p>MSBuild 里的通配符 <code>**</code> 表示部分路径, <code>*</code> 表示零个或多个字符. 想要匹配目录 <code>Project</code> 及其子目录下的所有 <code>.cs</code> 文件, 可以这么写 <code>Project/**/*.cs</code>. <a href=\"https://stackoverflow.com/questions/8532929/two-asterisks-in-file-path\" target=\"_blank\" rel=\"external\">参见这个网页.</a> </p>\n</li>\n</ol>"},{"title":"C#反射及其高级操作","date":"2017-12-05T11:55:45.000Z","_content":"\n详细讲解C#的反射, 实时编译, 动态加载程序集(Assembly)等功能.\n\n<!-- more -->\n\n### C#的编译机制\n\nC#的编译器会把C#源代码会编译成IL代码, 存在.exe或.dll文件中. 除了IL代码以外, 文件中还存有一些别的信息, 比如类型信息, 以及用户自定义的特性(Attribute). 这些代码逻辑之外的信息被叫做元数据(metadata).  \n反射就是读取并使用这些元数据的一种机制, 是C#元编程的途径之一.  \n\n程序集(Assembly)是最小的编译目标(Target). 通常我们会把某些文件编译到一个.exe或.dll, 它就是一个程序集. 这个概念和java的包(package), 以及python的模块(module)差不多. 不过需要注意一下, 尽管它的后缀名是 .exe/.dll, 它的格式与VisualC++编译结果有很大不同.\n\n如果你写的程序要使用一个程序集(或者说一个外部库), 我们会在编译或构建的时候指明:  \n`csc ./x.cs -out:x.exe -reference:SomeLib.dll # for csharp compiler.`  \n或者写到msbuild中:  \n`<Reference Include=\"SomeLib\"> <HintPath> ... </HintPath> </Reference>`  \n在我们的源代码里就可以使用了:  \n`using SomeLib; ...; `\n\n### 反射\n\n你可以通过反射机制调用你自己的程序中的元数据. 像这样:\n```CSharp\nusing System.Reflection;\nusing static System.Console;\npublic class __Main__\n{\n    public int x { get; private set; }\n    public int y;\n    public int One(int g) { return g; }\n    \n    public static void Main(string[] args)\n    {\n        Type t = typeof(__Main__); // 对于一个(编译期的)已知类型, 使用typeof关键字.\n        \n        // 输出\"__Main__\"\n        WriteLine(t.name);\n        \n        // 输出所有成员函数名称, 包括属性(properties), 默认构造方法(.ctor)等.\n        foreach(var m in t.GetMembers())\n            WriteLine(m.Name);\n        \n        // 调用方法; 输出\"2\". 注意对于变长参数和虚函数, 第三个参数Binder需要自定义.\n        WriteLine((int)t.InvokeMember(\"One\", BindingFlags.InvokeMethod, null, null, new object[]{2}));\n    }\n}\n```\n可以使用 `Activator.CreateInstance(Type)` 创建对应类型的对象.  \n可以使用 `object.GetType()` 获取一个表示对象的实际类型的Type对象.  \n此外还有 `Type.GetFields()` 等函数, 可以拿到除了源代码意外的一切信息(源码被编译成IL或汇编了).  \n可以使用 `Type.GetTypeCode(Type)` 获取内置基本类型的类型编码(用于switch-case).\n\n### 动态编译\n\nCodeDom的全称是**Code Documentation Object Model**, 是以XML的形式描述语言的一套规则和配套API. 它提供了类似于类型机制, 语法结构树等一堆用来描述代码的类. 这些类可以用来方便地生成支持语言的源代码, 或者从源代码提取逻辑. 不过我们这里不使用它们...  \nCodeDom提供了一套编程语言支持系统. 据说功能和编译器**Roslyn**重复了, 不过资料还是够多.  \nCodeDom内置三种语言的编译, 分别是C#, VB .Net, 还有JScript(微软自家的web编程语言, 好像是TypeScript前身).  \n\n我们可以用CodeDom进行实时文件编译, 像这样:\n```CSharp\nusing System.CodeDom;\nusing System.CodeDomCompiler;\n\n// 下方代码写在函数里...\nvar pr = CodeDomProvider.CreateProvider(\"C#\");\nvar opt = new CompilerParameters();\nopt.GenerateExecutable = false; // true则生成可执行文件(带有入口点的程序集), false生成链接库. 默认false.\nopt.GenerateInMemory = true; // 如果为true则直接生成到内存中, 不会保存到文件, 程序结束后直接销毁. 默认false.\nopt.ReferencedAssemblies.Add(\"System\"); // 外部库的绝对路径. 除非是系统库(放在编译器相同目录下)可以不写路径.\nCompilerResults cr = pr.CompileAssemblyFromSource(opt, new string[]{source}); // 编译.\nif(am == null) // 检查编译结果.\n{\n    WriteLine(\"Compile failed!\");\n    foreach(var err in cr.Errors) WriteLine(err.ToString());\n    return;\n}[p\nAssembly am = cr.CompiledAssembly; // 编译成功了就拿下程序集.\nforeach(Type c in am.GetTypes()) // 枚举程序集中每一个类. 然后干该干的事情...\n{\n    WriteLine(\"Class/Struct: \" + c.Namespace + \"::\" + c.Name);\n    c.InvokeMember(\"gg\", BindingFlags.InvokeMethod, null, null, null);\n    ...\n}\n```\n除此以外, CodeDomProvider还能解释执行C#代码.\n\n### 加载和删除程序集\n应用程序域(AppDomain, 下文简称域)是应用程序(Application)的一个子环境. 每个域都包含若干个被加载入内存中的程序集. 一个运行中的应用程序由至少一个域组成, 程序中的每一个线程都在一个域内运行其中的代码. 主线程(Main函数所在线程)运行在主应用程序域(main AppDomain)中. 在程序一开始执行Main函数之前, 运行时环境(CLR)会创建主域, 并加载所有需要的程序集——就是在编译选项中用`<Refernece ...>`指定的那些库, 然后创建主线程, 运行主函数.  \n加载进应用程序域的程序集不能卸载. CLR会解析程序集并把它编译到应用程序域中, 组织函数的入口点, 编译跳转指令(大概就是运行时链接吧). CLR还可能根据程序的运行状况和代码特点做内联编译来加速运行. 创建一个应用程序域并加载一个程序集的例子如下:\n```CSharp\n// u.cs, 编译到u.dll.\n// 注意编译时的文件名就是编译后这个程序集的名称. 所以要先编译到 *.dll, 再拷贝到想要的目录下.\nusing System;\nusing static System.Runtime.InteropServices.Marshal;\npublic class FunctionInvoker : MarshalByRefObject // 继承自MarshalByRefObject\n                                                  // 会使对象在域之间传递时作引用传递而不是值传递.\n{\n    ...\n}\n```\n```CSharp\nusing System;\n// 某个函数里...\nWriteLine(AppDomain.CurrentDomain.FriendlyName); // 使用当前线程所在程序集.\n\nAppDomain domain = new AppDomain(\"NewDomain\"); // 给创建的域一个\"友好的\"名字.\nWriteLine(domain.FriendlyName); // 输出\"NewDomain\".\n\n// 使用下面方法把程序集加载到指定的域中.\n// 注意我们不使用 AppDomain.Load 函数, 设定上, 这个函数只能被当前域调用.\n// 这个函数在NewDomain内创建一个程序集 y.dll 中定义的DK.Test对象.\n// 注意这个操作会让NewDomain加载 y.dll 程序集, 但是当前域不会.\ndomain.CreateInstanceFrom(\"./bin/y.dll\", \"DK.Test\");\n\n// 现在我们拿到了NewDomain域里的一个新对象的引用. 注意这个操作*会*把对应程序集加载到当前域.\nvar r = domain.CreateInstanceFromAndUnwrap(\n    \"./bin/u.dll\",\n    \"FunctionInvoker\");\n```\n现在当前域加载了程序集 `u.dll`, 我们新建的域加载了程序集 `u.dll` 和 `y.dll` ; 新建的域中还存有一个 `DK.Test` 对象, 一个 `FunctionInvoker` 对象; 在当前域中存有对新的域的引用, 还有一个对上面提到的 `FunctionInvoker` 对象的引用.  \n显然, 当前域加载了程序集 `u.dll` , 这样当前域和那个叫做 NewDomain 的域分别持有一份对程序集`u.dll` 的一份拷贝. 现在我们希望在不加载 `y.dll` 的情况下访问另一个AppDomain中的函数.  \n\n如果读者足够细心应该会发现上面某个类叫做 `FunctionInvoker`. 我们需要一种协议来在域之间做通信. 这种协议可以用反射实现, 举例如下:\n```CSharp\n// u.cs -> u.dll -> ./bin/u.dll\nusing System;\nusing System.Reflection;\npublic class FunctionInvoker : MarshalByRefObject\n{\n    public void Invoke(string type, string name, object target, params object[] args)\n    {\n        foreach(var a in AppDomain.CurrentDomain.GetAssemblies())\n        {\n            Type t = a.GetType(type);\n            if(t != null)\n            {\n                t.InvokeMember(name, BindingFlags.InvokeMethod, null, target, args);\n            }\n        }\n    }\n}\n```\n```CSharp\n// 在某函数中...\n// 创建新域.\nAppDomain domain = new AppDomain(\"NewDomain\");\n// 新域加载程序集 y.dll 并创建 DK.Test 对象.\ndomain.CreateInstanceFrom(\"./bin/y.dll\", \"DK.Test\");\n// 新域加载程序集 u.dll 并创建 FunctionInvoker 对象. 当前域加载程序集 u.dll.\nvar r = (FunctionInvoker)domain.CreateInstanceFromAndUnwrap(\n    \"./bin/u.dll\",\n    \"FunctionInvoker\");\n// 调用新域中的对象的函数.\nr.Invoke(\"DK.Test\", \"Out\", null);\n```\n注意这个`Invoke`函数. 它在程序集 u.dll 中被定义, 被两个域一起加载. 那这个`Invoke`是调用哪个域中的呢? 答案是新域NewDomain. 可以在 Invoke 函数中把 CurrentDomain.FriendlyName 输出出来印证这一点. 这样上面的 Invoke函数会执行并调用新域中的程序集 y.dll 中 DK.Test 类的 Out 方法. 由于是静态方法所以不需要传递对象.\n\n于是我们在当前域未加载 y.dll 的情况下调用了另一个域中程序集 y.dll 中的函数.\n\n删除程序集很简单, 把AppDomain删掉即可: `AppDomain.Unload(domain);`\n结合上边的即使编译, 我们就可以在不掐掉程序的情况下动态实时更新程序集了. 不过如果我们需要修改协议类FunctionInvoker, 那就只能重启程序了.\n","source":"_posts/csharp-reflection.md","raw":"---\ntitle: C#反射及其高级操作\ndate: 2017-12-05 19:55:45\ntags:\n---\n\n详细讲解C#的反射, 实时编译, 动态加载程序集(Assembly)等功能.\n\n<!-- more -->\n\n### C#的编译机制\n\nC#的编译器会把C#源代码会编译成IL代码, 存在.exe或.dll文件中. 除了IL代码以外, 文件中还存有一些别的信息, 比如类型信息, 以及用户自定义的特性(Attribute). 这些代码逻辑之外的信息被叫做元数据(metadata).  \n反射就是读取并使用这些元数据的一种机制, 是C#元编程的途径之一.  \n\n程序集(Assembly)是最小的编译目标(Target). 通常我们会把某些文件编译到一个.exe或.dll, 它就是一个程序集. 这个概念和java的包(package), 以及python的模块(module)差不多. 不过需要注意一下, 尽管它的后缀名是 .exe/.dll, 它的格式与VisualC++编译结果有很大不同.\n\n如果你写的程序要使用一个程序集(或者说一个外部库), 我们会在编译或构建的时候指明:  \n`csc ./x.cs -out:x.exe -reference:SomeLib.dll # for csharp compiler.`  \n或者写到msbuild中:  \n`<Reference Include=\"SomeLib\"> <HintPath> ... </HintPath> </Reference>`  \n在我们的源代码里就可以使用了:  \n`using SomeLib; ...; `\n\n### 反射\n\n你可以通过反射机制调用你自己的程序中的元数据. 像这样:\n```CSharp\nusing System.Reflection;\nusing static System.Console;\npublic class __Main__\n{\n    public int x { get; private set; }\n    public int y;\n    public int One(int g) { return g; }\n    \n    public static void Main(string[] args)\n    {\n        Type t = typeof(__Main__); // 对于一个(编译期的)已知类型, 使用typeof关键字.\n        \n        // 输出\"__Main__\"\n        WriteLine(t.name);\n        \n        // 输出所有成员函数名称, 包括属性(properties), 默认构造方法(.ctor)等.\n        foreach(var m in t.GetMembers())\n            WriteLine(m.Name);\n        \n        // 调用方法; 输出\"2\". 注意对于变长参数和虚函数, 第三个参数Binder需要自定义.\n        WriteLine((int)t.InvokeMember(\"One\", BindingFlags.InvokeMethod, null, null, new object[]{2}));\n    }\n}\n```\n可以使用 `Activator.CreateInstance(Type)` 创建对应类型的对象.  \n可以使用 `object.GetType()` 获取一个表示对象的实际类型的Type对象.  \n此外还有 `Type.GetFields()` 等函数, 可以拿到除了源代码意外的一切信息(源码被编译成IL或汇编了).  \n可以使用 `Type.GetTypeCode(Type)` 获取内置基本类型的类型编码(用于switch-case).\n\n### 动态编译\n\nCodeDom的全称是**Code Documentation Object Model**, 是以XML的形式描述语言的一套规则和配套API. 它提供了类似于类型机制, 语法结构树等一堆用来描述代码的类. 这些类可以用来方便地生成支持语言的源代码, 或者从源代码提取逻辑. 不过我们这里不使用它们...  \nCodeDom提供了一套编程语言支持系统. 据说功能和编译器**Roslyn**重复了, 不过资料还是够多.  \nCodeDom内置三种语言的编译, 分别是C#, VB .Net, 还有JScript(微软自家的web编程语言, 好像是TypeScript前身).  \n\n我们可以用CodeDom进行实时文件编译, 像这样:\n```CSharp\nusing System.CodeDom;\nusing System.CodeDomCompiler;\n\n// 下方代码写在函数里...\nvar pr = CodeDomProvider.CreateProvider(\"C#\");\nvar opt = new CompilerParameters();\nopt.GenerateExecutable = false; // true则生成可执行文件(带有入口点的程序集), false生成链接库. 默认false.\nopt.GenerateInMemory = true; // 如果为true则直接生成到内存中, 不会保存到文件, 程序结束后直接销毁. 默认false.\nopt.ReferencedAssemblies.Add(\"System\"); // 外部库的绝对路径. 除非是系统库(放在编译器相同目录下)可以不写路径.\nCompilerResults cr = pr.CompileAssemblyFromSource(opt, new string[]{source}); // 编译.\nif(am == null) // 检查编译结果.\n{\n    WriteLine(\"Compile failed!\");\n    foreach(var err in cr.Errors) WriteLine(err.ToString());\n    return;\n}[p\nAssembly am = cr.CompiledAssembly; // 编译成功了就拿下程序集.\nforeach(Type c in am.GetTypes()) // 枚举程序集中每一个类. 然后干该干的事情...\n{\n    WriteLine(\"Class/Struct: \" + c.Namespace + \"::\" + c.Name);\n    c.InvokeMember(\"gg\", BindingFlags.InvokeMethod, null, null, null);\n    ...\n}\n```\n除此以外, CodeDomProvider还能解释执行C#代码.\n\n### 加载和删除程序集\n应用程序域(AppDomain, 下文简称域)是应用程序(Application)的一个子环境. 每个域都包含若干个被加载入内存中的程序集. 一个运行中的应用程序由至少一个域组成, 程序中的每一个线程都在一个域内运行其中的代码. 主线程(Main函数所在线程)运行在主应用程序域(main AppDomain)中. 在程序一开始执行Main函数之前, 运行时环境(CLR)会创建主域, 并加载所有需要的程序集——就是在编译选项中用`<Refernece ...>`指定的那些库, 然后创建主线程, 运行主函数.  \n加载进应用程序域的程序集不能卸载. CLR会解析程序集并把它编译到应用程序域中, 组织函数的入口点, 编译跳转指令(大概就是运行时链接吧). CLR还可能根据程序的运行状况和代码特点做内联编译来加速运行. 创建一个应用程序域并加载一个程序集的例子如下:\n```CSharp\n// u.cs, 编译到u.dll.\n// 注意编译时的文件名就是编译后这个程序集的名称. 所以要先编译到 *.dll, 再拷贝到想要的目录下.\nusing System;\nusing static System.Runtime.InteropServices.Marshal;\npublic class FunctionInvoker : MarshalByRefObject // 继承自MarshalByRefObject\n                                                  // 会使对象在域之间传递时作引用传递而不是值传递.\n{\n    ...\n}\n```\n```CSharp\nusing System;\n// 某个函数里...\nWriteLine(AppDomain.CurrentDomain.FriendlyName); // 使用当前线程所在程序集.\n\nAppDomain domain = new AppDomain(\"NewDomain\"); // 给创建的域一个\"友好的\"名字.\nWriteLine(domain.FriendlyName); // 输出\"NewDomain\".\n\n// 使用下面方法把程序集加载到指定的域中.\n// 注意我们不使用 AppDomain.Load 函数, 设定上, 这个函数只能被当前域调用.\n// 这个函数在NewDomain内创建一个程序集 y.dll 中定义的DK.Test对象.\n// 注意这个操作会让NewDomain加载 y.dll 程序集, 但是当前域不会.\ndomain.CreateInstanceFrom(\"./bin/y.dll\", \"DK.Test\");\n\n// 现在我们拿到了NewDomain域里的一个新对象的引用. 注意这个操作*会*把对应程序集加载到当前域.\nvar r = domain.CreateInstanceFromAndUnwrap(\n    \"./bin/u.dll\",\n    \"FunctionInvoker\");\n```\n现在当前域加载了程序集 `u.dll`, 我们新建的域加载了程序集 `u.dll` 和 `y.dll` ; 新建的域中还存有一个 `DK.Test` 对象, 一个 `FunctionInvoker` 对象; 在当前域中存有对新的域的引用, 还有一个对上面提到的 `FunctionInvoker` 对象的引用.  \n显然, 当前域加载了程序集 `u.dll` , 这样当前域和那个叫做 NewDomain 的域分别持有一份对程序集`u.dll` 的一份拷贝. 现在我们希望在不加载 `y.dll` 的情况下访问另一个AppDomain中的函数.  \n\n如果读者足够细心应该会发现上面某个类叫做 `FunctionInvoker`. 我们需要一种协议来在域之间做通信. 这种协议可以用反射实现, 举例如下:\n```CSharp\n// u.cs -> u.dll -> ./bin/u.dll\nusing System;\nusing System.Reflection;\npublic class FunctionInvoker : MarshalByRefObject\n{\n    public void Invoke(string type, string name, object target, params object[] args)\n    {\n        foreach(var a in AppDomain.CurrentDomain.GetAssemblies())\n        {\n            Type t = a.GetType(type);\n            if(t != null)\n            {\n                t.InvokeMember(name, BindingFlags.InvokeMethod, null, target, args);\n            }\n        }\n    }\n}\n```\n```CSharp\n// 在某函数中...\n// 创建新域.\nAppDomain domain = new AppDomain(\"NewDomain\");\n// 新域加载程序集 y.dll 并创建 DK.Test 对象.\ndomain.CreateInstanceFrom(\"./bin/y.dll\", \"DK.Test\");\n// 新域加载程序集 u.dll 并创建 FunctionInvoker 对象. 当前域加载程序集 u.dll.\nvar r = (FunctionInvoker)domain.CreateInstanceFromAndUnwrap(\n    \"./bin/u.dll\",\n    \"FunctionInvoker\");\n// 调用新域中的对象的函数.\nr.Invoke(\"DK.Test\", \"Out\", null);\n```\n注意这个`Invoke`函数. 它在程序集 u.dll 中被定义, 被两个域一起加载. 那这个`Invoke`是调用哪个域中的呢? 答案是新域NewDomain. 可以在 Invoke 函数中把 CurrentDomain.FriendlyName 输出出来印证这一点. 这样上面的 Invoke函数会执行并调用新域中的程序集 y.dll 中 DK.Test 类的 Out 方法. 由于是静态方法所以不需要传递对象.\n\n于是我们在当前域未加载 y.dll 的情况下调用了另一个域中程序集 y.dll 中的函数.\n\n删除程序集很简单, 把AppDomain删掉即可: `AppDomain.Unload(domain);`\n结合上边的即使编译, 我们就可以在不掐掉程序的情况下动态实时更新程序集了. 不过如果我们需要修改协议类FunctionInvoker, 那就只能重启程序了.\n","slug":"csharp-reflection","published":1,"updated":"2017-12-07T02:40:47.424Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjavw90fu0000rlmpd16t74ji","content":"<p>详细讲解C#的反射, 实时编译, 动态加载程序集(Assembly)等功能.</p>\n<a id=\"more\"></a>\n<h3 id=\"C-的编译机制\"><a href=\"#C-的编译机制\" class=\"headerlink\" title=\"C#的编译机制\"></a>C#的编译机制</h3><p>C#的编译器会把C#源代码会编译成IL代码, 存在.exe或.dll文件中. 除了IL代码以外, 文件中还存有一些别的信息, 比如类型信息, 以及用户自定义的特性(Attribute). 这些代码逻辑之外的信息被叫做元数据(metadata).<br>反射就是读取并使用这些元数据的一种机制, 是C#元编程的途径之一.  </p>\n<p>程序集(Assembly)是最小的编译目标(Target). 通常我们会把某些文件编译到一个.exe或.dll, 它就是一个程序集. 这个概念和java的包(package), 以及python的模块(module)差不多. 不过需要注意一下, 尽管它的后缀名是 .exe/.dll, 它的格式与VisualC++编译结果有很大不同.</p>\n<p>如果你写的程序要使用一个程序集(或者说一个外部库), 我们会在编译或构建的时候指明:<br><code>csc ./x.cs -out:x.exe -reference:SomeLib.dll # for csharp compiler.</code><br>或者写到msbuild中:<br><code>&lt;Reference Include=&quot;SomeLib&quot;&gt; &lt;HintPath&gt; ... &lt;/HintPath&gt; &lt;/Reference&gt;</code><br>在我们的源代码里就可以使用了:<br><code>using SomeLib; ...;</code></p>\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><p>你可以通过反射机制调用你自己的程序中的元数据. 像这样:<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">using</span> System.Reflection;</div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">static</span> System.Console;</div><div class=\"line\">public class __Main__</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> x &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">private</span> <span class=\"keyword\">set</span>; &#125;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> y;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">One</span>(<span class=\"params\"><span class=\"keyword\">int</span> g</span>) </span>&#123; <span class=\"keyword\">return</span> g; &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"keyword\">string</span>[] args</span>)</span></div><div class=\"line\"><span class=\"function\">    </span>&#123;</div><div class=\"line\">        Type t = <span class=\"keyword\">typeof</span>(__Main__); <span class=\"comment\">// 对于一个(编译期的)已知类型, 使用typeof关键字.</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 输出\"__Main__\"</span></div><div class=\"line\">        WriteLine(t.name);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 输出所有成员函数名称, 包括属性(properties), 默认构造方法(.ctor)等.</span></div><div class=\"line\">        <span class=\"keyword\">foreach</span>(<span class=\"keyword\">var</span> m <span class=\"keyword\">in</span> t.GetMembers())</div><div class=\"line\">            WriteLine(m.Name);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 调用方法; 输出\"2\". 注意对于变长参数和虚函数, 第三个参数Binder需要自定义.</span></div><div class=\"line\">        WriteLine((<span class=\"keyword\">int</span>)t.InvokeMember(<span class=\"string\">\"One\"</span>, BindingFlags.InvokeMethod, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"keyword\">new</span> <span class=\"keyword\">object</span>[]&#123;<span class=\"number\">2</span>&#125;));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以使用 <code>Activator.CreateInstance(Type)</code> 创建对应类型的对象.<br>可以使用 <code>object.GetType()</code> 获取一个表示对象的实际类型的Type对象.<br>此外还有 <code>Type.GetFields()</code> 等函数, 可以拿到除了源代码意外的一切信息(源码被编译成IL或汇编了).<br>可以使用 <code>Type.GetTypeCode(Type)</code> 获取内置基本类型的类型编码(用于switch-case).</p>\n<h3 id=\"动态编译\"><a href=\"#动态编译\" class=\"headerlink\" title=\"动态编译\"></a>动态编译</h3><p>CodeDom的全称是<strong>Code Documentation Object Model</strong>, 是以XML的形式描述语言的一套规则和配套API. 它提供了类似于类型机制, 语法结构树等一堆用来描述代码的类. 这些类可以用来方便地生成支持语言的源代码, 或者从源代码提取逻辑. 不过我们这里不使用它们…<br>CodeDom提供了一套编程语言支持系统. 据说功能和编译器<strong>Roslyn</strong>重复了, 不过资料还是够多.<br>CodeDom内置三种语言的编译, 分别是C#, VB .Net, 还有JScript(微软自家的web编程语言, 好像是TypeScript前身).  </p>\n<p>我们可以用CodeDom进行实时文件编译, 像这样:<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">using</span> System.CodeDom;</div><div class=\"line\"><span class=\"keyword\">using</span> System.CodeDomCompiler;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 下方代码写在函数里...</span></div><div class=\"line\"><span class=\"keyword\">var</span> pr = CodeDomProvider.CreateProvider(<span class=\"string\">\"C#\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> opt = <span class=\"keyword\">new</span> CompilerParameters();</div><div class=\"line\">opt.GenerateExecutable = <span class=\"literal\">false</span>; <span class=\"comment\">// true则生成可执行文件(带有入口点的程序集), false生成链接库. 默认false.</span></div><div class=\"line\">opt.GenerateInMemory = <span class=\"literal\">true</span>; <span class=\"comment\">// 如果为true则直接生成到内存中, 不会保存到文件, 程序结束后直接销毁. 默认false.</span></div><div class=\"line\">opt.ReferencedAssemblies.Add(<span class=\"string\">\"System\"</span>); <span class=\"comment\">// 外部库的绝对路径. 除非是系统库(放在编译器相同目录下)可以不写路径.</span></div><div class=\"line\">CompilerResults cr = pr.CompileAssemblyFromSource(opt, <span class=\"keyword\">new</span> <span class=\"keyword\">string</span>[]&#123;source&#125;); <span class=\"comment\">// 编译.</span></div><div class=\"line\"><span class=\"keyword\">if</span>(am == <span class=\"literal\">null</span>) <span class=\"comment\">// 检查编译结果.</span></div><div class=\"line\">&#123;</div><div class=\"line\">    WriteLine(<span class=\"string\">\"Compile failed!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">foreach</span>(<span class=\"keyword\">var</span> err <span class=\"keyword\">in</span> cr.Errors) WriteLine(err.ToString());</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;[p</div><div class=\"line\">Assembly am = cr.CompiledAssembly; <span class=\"comment\">// 编译成功了就拿下程序集.</span></div><div class=\"line\"><span class=\"keyword\">foreach</span>(Type c <span class=\"keyword\">in</span> am.GetTypes()) <span class=\"comment\">// 枚举程序集中每一个类. 然后干该干的事情...</span></div><div class=\"line\">&#123;</div><div class=\"line\">    WriteLine(<span class=\"string\">\"Class/Struct: \"</span> + c.Namespace + <span class=\"string\">\"::\"</span> + c.Name);</div><div class=\"line\">    c.InvokeMember(<span class=\"string\">\"gg\"</span>, BindingFlags.InvokeMethod, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>除此以外, CodeDomProvider还能解释执行C#代码.</p>\n<h3 id=\"加载和删除程序集\"><a href=\"#加载和删除程序集\" class=\"headerlink\" title=\"加载和删除程序集\"></a>加载和删除程序集</h3><p>应用程序域(AppDomain, 下文简称域)是应用程序(Application)的一个子环境. 每个域都包含若干个被加载入内存中的程序集. 一个运行中的应用程序由至少一个域组成, 程序中的每一个线程都在一个域内运行其中的代码. 主线程(Main函数所在线程)运行在主应用程序域(main AppDomain)中. 在程序一开始执行Main函数之前, 运行时环境(CLR)会创建主域, 并加载所有需要的程序集——就是在编译选项中用<code>&lt;Refernece ...&gt;</code>指定的那些库, 然后创建主线程, 运行主函数.<br>加载进应用程序域的程序集不能卸载. CLR会解析程序集并把它编译到应用程序域中, 组织函数的入口点, 编译跳转指令(大概就是运行时链接吧). CLR还可能根据程序的运行状况和代码特点做内联编译来加速运行. 创建一个应用程序域并加载一个程序集的例子如下:<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// u.cs, 编译到u.dll.</span></div><div class=\"line\"><span class=\"comment\">// 注意编译时的文件名就是编译后这个程序集的名称. 所以要先编译到 *.dll, 再拷贝到想要的目录下.</span></div><div class=\"line\"><span class=\"keyword\">using</span> System;</div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">static</span> System.Runtime.InteropServices.Marshal;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">FunctionInvoker</span> : <span class=\"title\">MarshalByRefObject</span> <span class=\"comment\">// 继承自MarshalByRefObject</span></div><div class=\"line\">                                                  <span class=\"comment\">// 会使对象在域之间传递时作引用传递而不是值传递.</span></div><div class=\"line\">&#123;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">using</span> System;</div><div class=\"line\"><span class=\"comment\">// 某个函数里...</span></div><div class=\"line\">WriteLine(AppDomain.CurrentDomain.FriendlyName); <span class=\"comment\">// 使用当前线程所在程序集.</span></div><div class=\"line\"></div><div class=\"line\">AppDomain domain = <span class=\"keyword\">new</span> AppDomain(<span class=\"string\">\"NewDomain\"</span>); <span class=\"comment\">// 给创建的域一个\"友好的\"名字.</span></div><div class=\"line\">WriteLine(domain.FriendlyName); <span class=\"comment\">// 输出\"NewDomain\".</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用下面方法把程序集加载到指定的域中.</span></div><div class=\"line\"><span class=\"comment\">// 注意我们不使用 AppDomain.Load 函数, 设定上, 这个函数只能被当前域调用.</span></div><div class=\"line\"><span class=\"comment\">// 这个函数在NewDomain内创建一个程序集 y.dll 中定义的DK.Test对象.</span></div><div class=\"line\"><span class=\"comment\">// 注意这个操作会让NewDomain加载 y.dll 程序集, 但是当前域不会.</span></div><div class=\"line\">domain.CreateInstanceFrom(<span class=\"string\">\"./bin/y.dll\"</span>, <span class=\"string\">\"DK.Test\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 现在我们拿到了NewDomain域里的一个新对象的引用. 注意这个操作*会*把对应程序集加载到当前域.</span></div><div class=\"line\"><span class=\"keyword\">var</span> r = domain.CreateInstanceFromAndUnwrap(</div><div class=\"line\">    <span class=\"string\">\"./bin/u.dll\"</span>,</div><div class=\"line\">    <span class=\"string\">\"FunctionInvoker\"</span>);</div></pre></td></tr></table></figure>\n<p>现在当前域加载了程序集 <code>u.dll</code>, 我们新建的域加载了程序集 <code>u.dll</code> 和 <code>y.dll</code> ; 新建的域中还存有一个 <code>DK.Test</code> 对象, 一个 <code>FunctionInvoker</code> 对象; 在当前域中存有对新的域的引用, 还有一个对上面提到的 <code>FunctionInvoker</code> 对象的引用.<br>显然, 当前域加载了程序集 <code>u.dll</code> , 这样当前域和那个叫做 NewDomain 的域分别持有一份对程序集<code>u.dll</code> 的一份拷贝. 现在我们希望在不加载 <code>y.dll</code> 的情况下访问另一个AppDomain中的函数.  </p>\n<p>如果读者足够细心应该会发现上面某个类叫做 <code>FunctionInvoker</code>. 我们需要一种协议来在域之间做通信. 这种协议可以用反射实现, 举例如下:<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// u.cs -&gt; u.dll -&gt; ./bin/u.dll</span></div><div class=\"line\"><span class=\"keyword\">using</span> System;</div><div class=\"line\"><span class=\"keyword\">using</span> System.Reflection;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">FunctionInvoker</span> : <span class=\"title\">MarshalByRefObject</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Invoke</span>(<span class=\"params\"><span class=\"keyword\">string</span> type, <span class=\"keyword\">string</span> name, <span class=\"keyword\">object</span> target, <span class=\"keyword\">params</span> <span class=\"keyword\">object</span>[] args</span>)</span></div><div class=\"line\"><span class=\"function\">    </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">foreach</span>(<span class=\"keyword\">var</span> a <span class=\"keyword\">in</span> AppDomain.CurrentDomain.GetAssemblies())</div><div class=\"line\">        &#123;</div><div class=\"line\">            Type t = a.GetType(type);</div><div class=\"line\">            <span class=\"keyword\">if</span>(t != <span class=\"literal\">null</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                t.InvokeMember(name, BindingFlags.InvokeMethod, <span class=\"literal\">null</span>, target, args);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在某函数中...</span></div><div class=\"line\"><span class=\"comment\">// 创建新域.</span></div><div class=\"line\">AppDomain domain = <span class=\"keyword\">new</span> AppDomain(<span class=\"string\">\"NewDomain\"</span>);</div><div class=\"line\"><span class=\"comment\">// 新域加载程序集 y.dll 并创建 DK.Test 对象.</span></div><div class=\"line\">domain.CreateInstanceFrom(<span class=\"string\">\"./bin/y.dll\"</span>, <span class=\"string\">\"DK.Test\"</span>);</div><div class=\"line\"><span class=\"comment\">// 新域加载程序集 u.dll 并创建 FunctionInvoker 对象. 当前域加载程序集 u.dll.</span></div><div class=\"line\"><span class=\"keyword\">var</span> r = (FunctionInvoker)domain.CreateInstanceFromAndUnwrap(</div><div class=\"line\">    <span class=\"string\">\"./bin/u.dll\"</span>,</div><div class=\"line\">    <span class=\"string\">\"FunctionInvoker\"</span>);</div><div class=\"line\"><span class=\"comment\">// 调用新域中的对象的函数.</span></div><div class=\"line\">r.Invoke(<span class=\"string\">\"DK.Test\"</span>, <span class=\"string\">\"Out\"</span>, <span class=\"literal\">null</span>);</div></pre></td></tr></table></figure>\n<p>注意这个<code>Invoke</code>函数. 它在程序集 u.dll 中被定义, 被两个域一起加载. 那这个<code>Invoke</code>是调用哪个域中的呢? 答案是新域NewDomain. 可以在 Invoke 函数中把 CurrentDomain.FriendlyName 输出出来印证这一点. 这样上面的 Invoke函数会执行并调用新域中的程序集 y.dll 中 DK.Test 类的 Out 方法. 由于是静态方法所以不需要传递对象.</p>\n<p>于是我们在当前域未加载 y.dll 的情况下调用了另一个域中程序集 y.dll 中的函数.</p>\n<p>删除程序集很简单, 把AppDomain删掉即可: <code>AppDomain.Unload(domain);</code><br>结合上边的即使编译, 我们就可以在不掐掉程序的情况下动态实时更新程序集了. 不过如果我们需要修改协议类FunctionInvoker, 那就只能重启程序了.</p>\n","site":{"data":{}},"excerpt":"<p>详细讲解C#的反射, 实时编译, 动态加载程序集(Assembly)等功能.</p>","more":"<h3 id=\"C-的编译机制\"><a href=\"#C-的编译机制\" class=\"headerlink\" title=\"C#的编译机制\"></a>C#的编译机制</h3><p>C#的编译器会把C#源代码会编译成IL代码, 存在.exe或.dll文件中. 除了IL代码以外, 文件中还存有一些别的信息, 比如类型信息, 以及用户自定义的特性(Attribute). 这些代码逻辑之外的信息被叫做元数据(metadata).<br>反射就是读取并使用这些元数据的一种机制, 是C#元编程的途径之一.  </p>\n<p>程序集(Assembly)是最小的编译目标(Target). 通常我们会把某些文件编译到一个.exe或.dll, 它就是一个程序集. 这个概念和java的包(package), 以及python的模块(module)差不多. 不过需要注意一下, 尽管它的后缀名是 .exe/.dll, 它的格式与VisualC++编译结果有很大不同.</p>\n<p>如果你写的程序要使用一个程序集(或者说一个外部库), 我们会在编译或构建的时候指明:<br><code>csc ./x.cs -out:x.exe -reference:SomeLib.dll # for csharp compiler.</code><br>或者写到msbuild中:<br><code>&lt;Reference Include=&quot;SomeLib&quot;&gt; &lt;HintPath&gt; ... &lt;/HintPath&gt; &lt;/Reference&gt;</code><br>在我们的源代码里就可以使用了:<br><code>using SomeLib; ...;</code></p>\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><p>你可以通过反射机制调用你自己的程序中的元数据. 像这样:<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">using</span> System.Reflection;</div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">static</span> System.Console;</div><div class=\"line\">public class __Main__</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> x &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">private</span> <span class=\"keyword\">set</span>; &#125;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> y;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">One</span>(<span class=\"params\"><span class=\"keyword\">int</span> g</span>) </span>&#123; <span class=\"keyword\">return</span> g; &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>(<span class=\"params\"><span class=\"keyword\">string</span>[] args</span>)</span></div><div class=\"line\"><span class=\"function\">    </span>&#123;</div><div class=\"line\">        Type t = <span class=\"keyword\">typeof</span>(__Main__); <span class=\"comment\">// 对于一个(编译期的)已知类型, 使用typeof关键字.</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 输出\"__Main__\"</span></div><div class=\"line\">        WriteLine(t.name);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 输出所有成员函数名称, 包括属性(properties), 默认构造方法(.ctor)等.</span></div><div class=\"line\">        <span class=\"keyword\">foreach</span>(<span class=\"keyword\">var</span> m <span class=\"keyword\">in</span> t.GetMembers())</div><div class=\"line\">            WriteLine(m.Name);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// 调用方法; 输出\"2\". 注意对于变长参数和虚函数, 第三个参数Binder需要自定义.</span></div><div class=\"line\">        WriteLine((<span class=\"keyword\">int</span>)t.InvokeMember(<span class=\"string\">\"One\"</span>, BindingFlags.InvokeMethod, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"keyword\">new</span> <span class=\"keyword\">object</span>[]&#123;<span class=\"number\">2</span>&#125;));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以使用 <code>Activator.CreateInstance(Type)</code> 创建对应类型的对象.<br>可以使用 <code>object.GetType()</code> 获取一个表示对象的实际类型的Type对象.<br>此外还有 <code>Type.GetFields()</code> 等函数, 可以拿到除了源代码意外的一切信息(源码被编译成IL或汇编了).<br>可以使用 <code>Type.GetTypeCode(Type)</code> 获取内置基本类型的类型编码(用于switch-case).</p>\n<h3 id=\"动态编译\"><a href=\"#动态编译\" class=\"headerlink\" title=\"动态编译\"></a>动态编译</h3><p>CodeDom的全称是<strong>Code Documentation Object Model</strong>, 是以XML的形式描述语言的一套规则和配套API. 它提供了类似于类型机制, 语法结构树等一堆用来描述代码的类. 这些类可以用来方便地生成支持语言的源代码, 或者从源代码提取逻辑. 不过我们这里不使用它们…<br>CodeDom提供了一套编程语言支持系统. 据说功能和编译器<strong>Roslyn</strong>重复了, 不过资料还是够多.<br>CodeDom内置三种语言的编译, 分别是C#, VB .Net, 还有JScript(微软自家的web编程语言, 好像是TypeScript前身).  </p>\n<p>我们可以用CodeDom进行实时文件编译, 像这样:<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">using</span> System.CodeDom;</div><div class=\"line\"><span class=\"keyword\">using</span> System.CodeDomCompiler;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 下方代码写在函数里...</span></div><div class=\"line\"><span class=\"keyword\">var</span> pr = CodeDomProvider.CreateProvider(<span class=\"string\">\"C#\"</span>);</div><div class=\"line\"><span class=\"keyword\">var</span> opt = <span class=\"keyword\">new</span> CompilerParameters();</div><div class=\"line\">opt.GenerateExecutable = <span class=\"literal\">false</span>; <span class=\"comment\">// true则生成可执行文件(带有入口点的程序集), false生成链接库. 默认false.</span></div><div class=\"line\">opt.GenerateInMemory = <span class=\"literal\">true</span>; <span class=\"comment\">// 如果为true则直接生成到内存中, 不会保存到文件, 程序结束后直接销毁. 默认false.</span></div><div class=\"line\">opt.ReferencedAssemblies.Add(<span class=\"string\">\"System\"</span>); <span class=\"comment\">// 外部库的绝对路径. 除非是系统库(放在编译器相同目录下)可以不写路径.</span></div><div class=\"line\">CompilerResults cr = pr.CompileAssemblyFromSource(opt, <span class=\"keyword\">new</span> <span class=\"keyword\">string</span>[]&#123;source&#125;); <span class=\"comment\">// 编译.</span></div><div class=\"line\"><span class=\"keyword\">if</span>(am == <span class=\"literal\">null</span>) <span class=\"comment\">// 检查编译结果.</span></div><div class=\"line\">&#123;</div><div class=\"line\">    WriteLine(<span class=\"string\">\"Compile failed!\"</span>);</div><div class=\"line\">    <span class=\"keyword\">foreach</span>(<span class=\"keyword\">var</span> err <span class=\"keyword\">in</span> cr.Errors) WriteLine(err.ToString());</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;[p</div><div class=\"line\">Assembly am = cr.CompiledAssembly; <span class=\"comment\">// 编译成功了就拿下程序集.</span></div><div class=\"line\"><span class=\"keyword\">foreach</span>(Type c <span class=\"keyword\">in</span> am.GetTypes()) <span class=\"comment\">// 枚举程序集中每一个类. 然后干该干的事情...</span></div><div class=\"line\">&#123;</div><div class=\"line\">    WriteLine(<span class=\"string\">\"Class/Struct: \"</span> + c.Namespace + <span class=\"string\">\"::\"</span> + c.Name);</div><div class=\"line\">    c.InvokeMember(<span class=\"string\">\"gg\"</span>, BindingFlags.InvokeMethod, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>);</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>除此以外, CodeDomProvider还能解释执行C#代码.</p>\n<h3 id=\"加载和删除程序集\"><a href=\"#加载和删除程序集\" class=\"headerlink\" title=\"加载和删除程序集\"></a>加载和删除程序集</h3><p>应用程序域(AppDomain, 下文简称域)是应用程序(Application)的一个子环境. 每个域都包含若干个被加载入内存中的程序集. 一个运行中的应用程序由至少一个域组成, 程序中的每一个线程都在一个域内运行其中的代码. 主线程(Main函数所在线程)运行在主应用程序域(main AppDomain)中. 在程序一开始执行Main函数之前, 运行时环境(CLR)会创建主域, 并加载所有需要的程序集——就是在编译选项中用<code>&lt;Refernece ...&gt;</code>指定的那些库, 然后创建主线程, 运行主函数.<br>加载进应用程序域的程序集不能卸载. CLR会解析程序集并把它编译到应用程序域中, 组织函数的入口点, 编译跳转指令(大概就是运行时链接吧). CLR还可能根据程序的运行状况和代码特点做内联编译来加速运行. 创建一个应用程序域并加载一个程序集的例子如下:<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// u.cs, 编译到u.dll.</span></div><div class=\"line\"><span class=\"comment\">// 注意编译时的文件名就是编译后这个程序集的名称. 所以要先编译到 *.dll, 再拷贝到想要的目录下.</span></div><div class=\"line\"><span class=\"keyword\">using</span> System;</div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">static</span> System.Runtime.InteropServices.Marshal;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">FunctionInvoker</span> : <span class=\"title\">MarshalByRefObject</span> <span class=\"comment\">// 继承自MarshalByRefObject</span></div><div class=\"line\">                                                  <span class=\"comment\">// 会使对象在域之间传递时作引用传递而不是值传递.</span></div><div class=\"line\">&#123;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">using</span> System;</div><div class=\"line\"><span class=\"comment\">// 某个函数里...</span></div><div class=\"line\">WriteLine(AppDomain.CurrentDomain.FriendlyName); <span class=\"comment\">// 使用当前线程所在程序集.</span></div><div class=\"line\"></div><div class=\"line\">AppDomain domain = <span class=\"keyword\">new</span> AppDomain(<span class=\"string\">\"NewDomain\"</span>); <span class=\"comment\">// 给创建的域一个\"友好的\"名字.</span></div><div class=\"line\">WriteLine(domain.FriendlyName); <span class=\"comment\">// 输出\"NewDomain\".</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用下面方法把程序集加载到指定的域中.</span></div><div class=\"line\"><span class=\"comment\">// 注意我们不使用 AppDomain.Load 函数, 设定上, 这个函数只能被当前域调用.</span></div><div class=\"line\"><span class=\"comment\">// 这个函数在NewDomain内创建一个程序集 y.dll 中定义的DK.Test对象.</span></div><div class=\"line\"><span class=\"comment\">// 注意这个操作会让NewDomain加载 y.dll 程序集, 但是当前域不会.</span></div><div class=\"line\">domain.CreateInstanceFrom(<span class=\"string\">\"./bin/y.dll\"</span>, <span class=\"string\">\"DK.Test\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 现在我们拿到了NewDomain域里的一个新对象的引用. 注意这个操作*会*把对应程序集加载到当前域.</span></div><div class=\"line\"><span class=\"keyword\">var</span> r = domain.CreateInstanceFromAndUnwrap(</div><div class=\"line\">    <span class=\"string\">\"./bin/u.dll\"</span>,</div><div class=\"line\">    <span class=\"string\">\"FunctionInvoker\"</span>);</div></pre></td></tr></table></figure>\n<p>现在当前域加载了程序集 <code>u.dll</code>, 我们新建的域加载了程序集 <code>u.dll</code> 和 <code>y.dll</code> ; 新建的域中还存有一个 <code>DK.Test</code> 对象, 一个 <code>FunctionInvoker</code> 对象; 在当前域中存有对新的域的引用, 还有一个对上面提到的 <code>FunctionInvoker</code> 对象的引用.<br>显然, 当前域加载了程序集 <code>u.dll</code> , 这样当前域和那个叫做 NewDomain 的域分别持有一份对程序集<code>u.dll</code> 的一份拷贝. 现在我们希望在不加载 <code>y.dll</code> 的情况下访问另一个AppDomain中的函数.  </p>\n<p>如果读者足够细心应该会发现上面某个类叫做 <code>FunctionInvoker</code>. 我们需要一种协议来在域之间做通信. 这种协议可以用反射实现, 举例如下:<br><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// u.cs -&gt; u.dll -&gt; ./bin/u.dll</span></div><div class=\"line\"><span class=\"keyword\">using</span> System;</div><div class=\"line\"><span class=\"keyword\">using</span> System.Reflection;</div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">FunctionInvoker</span> : <span class=\"title\">MarshalByRefObject</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Invoke</span>(<span class=\"params\"><span class=\"keyword\">string</span> type, <span class=\"keyword\">string</span> name, <span class=\"keyword\">object</span> target, <span class=\"keyword\">params</span> <span class=\"keyword\">object</span>[] args</span>)</span></div><div class=\"line\"><span class=\"function\">    </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">foreach</span>(<span class=\"keyword\">var</span> a <span class=\"keyword\">in</span> AppDomain.CurrentDomain.GetAssemblies())</div><div class=\"line\">        &#123;</div><div class=\"line\">            Type t = a.GetType(type);</div><div class=\"line\">            <span class=\"keyword\">if</span>(t != <span class=\"literal\">null</span>)</div><div class=\"line\">            &#123;</div><div class=\"line\">                t.InvokeMember(name, BindingFlags.InvokeMethod, <span class=\"literal\">null</span>, target, args);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在某函数中...</span></div><div class=\"line\"><span class=\"comment\">// 创建新域.</span></div><div class=\"line\">AppDomain domain = <span class=\"keyword\">new</span> AppDomain(<span class=\"string\">\"NewDomain\"</span>);</div><div class=\"line\"><span class=\"comment\">// 新域加载程序集 y.dll 并创建 DK.Test 对象.</span></div><div class=\"line\">domain.CreateInstanceFrom(<span class=\"string\">\"./bin/y.dll\"</span>, <span class=\"string\">\"DK.Test\"</span>);</div><div class=\"line\"><span class=\"comment\">// 新域加载程序集 u.dll 并创建 FunctionInvoker 对象. 当前域加载程序集 u.dll.</span></div><div class=\"line\"><span class=\"keyword\">var</span> r = (FunctionInvoker)domain.CreateInstanceFromAndUnwrap(</div><div class=\"line\">    <span class=\"string\">\"./bin/u.dll\"</span>,</div><div class=\"line\">    <span class=\"string\">\"FunctionInvoker\"</span>);</div><div class=\"line\"><span class=\"comment\">// 调用新域中的对象的函数.</span></div><div class=\"line\">r.Invoke(<span class=\"string\">\"DK.Test\"</span>, <span class=\"string\">\"Out\"</span>, <span class=\"literal\">null</span>);</div></pre></td></tr></table></figure>\n<p>注意这个<code>Invoke</code>函数. 它在程序集 u.dll 中被定义, 被两个域一起加载. 那这个<code>Invoke</code>是调用哪个域中的呢? 答案是新域NewDomain. 可以在 Invoke 函数中把 CurrentDomain.FriendlyName 输出出来印证这一点. 这样上面的 Invoke函数会执行并调用新域中的程序集 y.dll 中 DK.Test 类的 Out 方法. 由于是静态方法所以不需要传递对象.</p>\n<p>于是我们在当前域未加载 y.dll 的情况下调用了另一个域中程序集 y.dll 中的函数.</p>\n<p>删除程序集很简单, 把AppDomain删掉即可: <code>AppDomain.Unload(domain);</code><br>结合上边的即使编译, 我们就可以在不掐掉程序的情况下动态实时更新程序集了. 不过如果我们需要修改协议类FunctionInvoker, 那就只能重启程序了.</p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjatnxnm20003nhmpg3clwr38","tag_id":"cjatnxnmb0004nhmpmy1q4anw","_id":"cjatnxnml0006nhmprpjiv7he"},{"post_id":"cjatnxnm20003nhmpg3clwr38","tag_id":"cjatnxnmk0005nhmpuv43p5aq","_id":"cjatnxnml0007nhmp3lol69df"},{"post_id":"cjatnxnmu0009nhmp3r1ts0ix","tag_id":"cjatnxnmb0004nhmpmy1q4anw","_id":"cjatnxnn8000enhmp1er622yp"},{"post_id":"cjatnxnmu0009nhmp3r1ts0ix","tag_id":"cjatnxnn6000cnhmpmmgcnydj","_id":"cjatnxnn8000fnhmpp7ky6rrn"},{"post_id":"cjatnxnmu0009nhmp3r1ts0ix","tag_id":"cjatnxnn7000dnhmpfh8keff2","_id":"cjatnxnn9000gnhmp9sm4das6"}],"Tag":[{"name":"C#","_id":"cjatnxnmb0004nhmpmy1q4anw"},{"name":"OpenTK","_id":"cjatnxnmk0005nhmpuv43p5aq"},{"name":"Mono","_id":"cjatnxnn6000cnhmpmmgcnydj"},{"name":"Linux","_id":"cjatnxnn7000dnhmpfh8keff2"}]}}